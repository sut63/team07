// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/team07/app/ent/ambulance"
	"github.com/team07/app/ent/carbrand"
	"github.com/team07/app/ent/carcheckinout"
	"github.com/team07/app/ent/carinspection"
	"github.com/team07/app/ent/carrepairrecord"
	"github.com/team07/app/ent/carservice"
	"github.com/team07/app/ent/distance"
	"github.com/team07/app/ent/inspectionresult"
	"github.com/team07/app/ent/insurance"
	"github.com/team07/app/ent/jobposition"
	"github.com/team07/app/ent/purpose"
	"github.com/team07/app/ent/receive"
	"github.com/team07/app/ent/repairing"
	"github.com/team07/app/ent/send"
	"github.com/team07/app/ent/transport"
	"github.com/team07/app/ent/urgent"
	"github.com/team07/app/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAmbulance        = "Ambulance"
	TypeCarCheckInOut    = "CarCheckInOut"
	TypeCarInspection    = "CarInspection"
	TypeCarRepairrecord  = "CarRepairrecord"
	TypeCarbrand         = "Carbrand"
	TypeCarregister      = "Carregister"
	TypeCarservice       = "Carservice"
	TypeDeliver          = "Deliver"
	TypeDistance         = "Distance"
	TypeInspectionResult = "InspectionResult"
	TypeInsurance        = "Insurance"
	TypeJobPosition      = "JobPosition"
	TypePurpose          = "Purpose"
	TypeReceive          = "Receive"
	TypeRepairing        = "Repairing"
	TypeSend             = "Send"
	TypeTransport        = "Transport"
	TypeUrgent           = "Urgent"
	TypeUser             = "User"
)

// AmbulanceMutation represents an operation that mutate the Ambulances
// nodes in the graph.
type AmbulanceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	carregistration       *string
	registerat            *time.Time
	clearedFields         map[string]struct{}
	hasbrand              *int
	clearedhasbrand       bool
	hasinsurance          *int
	clearedhasinsurance   bool
	hasstatus             *int
	clearedhasstatus      bool
	hasuser               *int
	clearedhasuser        bool
	carinspections        map[int]struct{}
	removedcarinspections map[int]struct{}
	carcheckinout         map[int]struct{}
	removedcarcheckinout  map[int]struct{}
	ambulance             map[int]struct{}
	removedambulance      map[int]struct{}
	done                  bool
	oldValue              func(context.Context) (*Ambulance, error)
}

var _ ent.Mutation = (*AmbulanceMutation)(nil)

// ambulanceOption allows to manage the mutation configuration using functional options.
type ambulanceOption func(*AmbulanceMutation)

// newAmbulanceMutation creates new mutation for $n.Name.
func newAmbulanceMutation(c config, op Op, opts ...ambulanceOption) *AmbulanceMutation {
	m := &AmbulanceMutation{
		config:        c,
		op:            op,
		typ:           TypeAmbulance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAmbulanceID sets the id field of the mutation.
func withAmbulanceID(id int) ambulanceOption {
	return func(m *AmbulanceMutation) {
		var (
			err   error
			once  sync.Once
			value *Ambulance
		)
		m.oldValue = func(ctx context.Context) (*Ambulance, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ambulance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAmbulance sets the old Ambulance of the mutation.
func withAmbulance(node *Ambulance) ambulanceOption {
	return func(m *AmbulanceMutation) {
		m.oldValue = func(context.Context) (*Ambulance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AmbulanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AmbulanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AmbulanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCarregistration sets the carregistration field.
func (m *AmbulanceMutation) SetCarregistration(s string) {
	m.carregistration = &s
}

// Carregistration returns the carregistration value in the mutation.
func (m *AmbulanceMutation) Carregistration() (r string, exists bool) {
	v := m.carregistration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarregistration returns the old carregistration value of the Ambulance.
// If the Ambulance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AmbulanceMutation) OldCarregistration(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCarregistration is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCarregistration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarregistration: %w", err)
	}
	return oldValue.Carregistration, nil
}

// ResetCarregistration reset all changes of the "carregistration" field.
func (m *AmbulanceMutation) ResetCarregistration() {
	m.carregistration = nil
}

// SetRegisterat sets the registerat field.
func (m *AmbulanceMutation) SetRegisterat(t time.Time) {
	m.registerat = &t
}

// Registerat returns the registerat value in the mutation.
func (m *AmbulanceMutation) Registerat() (r time.Time, exists bool) {
	v := m.registerat
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterat returns the old registerat value of the Ambulance.
// If the Ambulance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AmbulanceMutation) OldRegisterat(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRegisterat is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRegisterat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterat: %w", err)
	}
	return oldValue.Registerat, nil
}

// ResetRegisterat reset all changes of the "registerat" field.
func (m *AmbulanceMutation) ResetRegisterat() {
	m.registerat = nil
}

// SetHasbrandID sets the hasbrand edge to Carbrand by id.
func (m *AmbulanceMutation) SetHasbrandID(id int) {
	m.hasbrand = &id
}

// ClearHasbrand clears the hasbrand edge to Carbrand.
func (m *AmbulanceMutation) ClearHasbrand() {
	m.clearedhasbrand = true
}

// HasbrandCleared returns if the edge hasbrand was cleared.
func (m *AmbulanceMutation) HasbrandCleared() bool {
	return m.clearedhasbrand
}

// HasbrandID returns the hasbrand id in the mutation.
func (m *AmbulanceMutation) HasbrandID() (id int, exists bool) {
	if m.hasbrand != nil {
		return *m.hasbrand, true
	}
	return
}

// HasbrandIDs returns the hasbrand ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// HasbrandID instead. It exists only for internal usage by the builders.
func (m *AmbulanceMutation) HasbrandIDs() (ids []int) {
	if id := m.hasbrand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHasbrand reset all changes of the "hasbrand" edge.
func (m *AmbulanceMutation) ResetHasbrand() {
	m.hasbrand = nil
	m.clearedhasbrand = false
}

// SetHasinsuranceID sets the hasinsurance edge to Insurance by id.
func (m *AmbulanceMutation) SetHasinsuranceID(id int) {
	m.hasinsurance = &id
}

// ClearHasinsurance clears the hasinsurance edge to Insurance.
func (m *AmbulanceMutation) ClearHasinsurance() {
	m.clearedhasinsurance = true
}

// HasinsuranceCleared returns if the edge hasinsurance was cleared.
func (m *AmbulanceMutation) HasinsuranceCleared() bool {
	return m.clearedhasinsurance
}

// HasinsuranceID returns the hasinsurance id in the mutation.
func (m *AmbulanceMutation) HasinsuranceID() (id int, exists bool) {
	if m.hasinsurance != nil {
		return *m.hasinsurance, true
	}
	return
}

// HasinsuranceIDs returns the hasinsurance ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// HasinsuranceID instead. It exists only for internal usage by the builders.
func (m *AmbulanceMutation) HasinsuranceIDs() (ids []int) {
	if id := m.hasinsurance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHasinsurance reset all changes of the "hasinsurance" edge.
func (m *AmbulanceMutation) ResetHasinsurance() {
	m.hasinsurance = nil
	m.clearedhasinsurance = false
}

// SetHasstatusID sets the hasstatus edge to InspectionResult by id.
func (m *AmbulanceMutation) SetHasstatusID(id int) {
	m.hasstatus = &id
}

// ClearHasstatus clears the hasstatus edge to InspectionResult.
func (m *AmbulanceMutation) ClearHasstatus() {
	m.clearedhasstatus = true
}

// HasstatusCleared returns if the edge hasstatus was cleared.
func (m *AmbulanceMutation) HasstatusCleared() bool {
	return m.clearedhasstatus
}

// HasstatusID returns the hasstatus id in the mutation.
func (m *AmbulanceMutation) HasstatusID() (id int, exists bool) {
	if m.hasstatus != nil {
		return *m.hasstatus, true
	}
	return
}

// HasstatusIDs returns the hasstatus ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// HasstatusID instead. It exists only for internal usage by the builders.
func (m *AmbulanceMutation) HasstatusIDs() (ids []int) {
	if id := m.hasstatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHasstatus reset all changes of the "hasstatus" edge.
func (m *AmbulanceMutation) ResetHasstatus() {
	m.hasstatus = nil
	m.clearedhasstatus = false
}

// SetHasuserID sets the hasuser edge to User by id.
func (m *AmbulanceMutation) SetHasuserID(id int) {
	m.hasuser = &id
}

// ClearHasuser clears the hasuser edge to User.
func (m *AmbulanceMutation) ClearHasuser() {
	m.clearedhasuser = true
}

// HasuserCleared returns if the edge hasuser was cleared.
func (m *AmbulanceMutation) HasuserCleared() bool {
	return m.clearedhasuser
}

// HasuserID returns the hasuser id in the mutation.
func (m *AmbulanceMutation) HasuserID() (id int, exists bool) {
	if m.hasuser != nil {
		return *m.hasuser, true
	}
	return
}

// HasuserIDs returns the hasuser ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// HasuserID instead. It exists only for internal usage by the builders.
func (m *AmbulanceMutation) HasuserIDs() (ids []int) {
	if id := m.hasuser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHasuser reset all changes of the "hasuser" edge.
func (m *AmbulanceMutation) ResetHasuser() {
	m.hasuser = nil
	m.clearedhasuser = false
}

// AddCarinspectionIDs adds the carinspections edge to CarInspection by ids.
func (m *AmbulanceMutation) AddCarinspectionIDs(ids ...int) {
	if m.carinspections == nil {
		m.carinspections = make(map[int]struct{})
	}
	for i := range ids {
		m.carinspections[ids[i]] = struct{}{}
	}
}

// RemoveCarinspectionIDs removes the carinspections edge to CarInspection by ids.
func (m *AmbulanceMutation) RemoveCarinspectionIDs(ids ...int) {
	if m.removedcarinspections == nil {
		m.removedcarinspections = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcarinspections[ids[i]] = struct{}{}
	}
}

// RemovedCarinspections returns the removed ids of carinspections.
func (m *AmbulanceMutation) RemovedCarinspectionsIDs() (ids []int) {
	for id := range m.removedcarinspections {
		ids = append(ids, id)
	}
	return
}

// CarinspectionsIDs returns the carinspections ids in the mutation.
func (m *AmbulanceMutation) CarinspectionsIDs() (ids []int) {
	for id := range m.carinspections {
		ids = append(ids, id)
	}
	return
}

// ResetCarinspections reset all changes of the "carinspections" edge.
func (m *AmbulanceMutation) ResetCarinspections() {
	m.carinspections = nil
	m.removedcarinspections = nil
}

// AddCarcheckinoutIDs adds the carcheckinout edge to CarCheckInOut by ids.
func (m *AmbulanceMutation) AddCarcheckinoutIDs(ids ...int) {
	if m.carcheckinout == nil {
		m.carcheckinout = make(map[int]struct{})
	}
	for i := range ids {
		m.carcheckinout[ids[i]] = struct{}{}
	}
}

// RemoveCarcheckinoutIDs removes the carcheckinout edge to CarCheckInOut by ids.
func (m *AmbulanceMutation) RemoveCarcheckinoutIDs(ids ...int) {
	if m.removedcarcheckinout == nil {
		m.removedcarcheckinout = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcarcheckinout[ids[i]] = struct{}{}
	}
}

// RemovedCarcheckinout returns the removed ids of carcheckinout.
func (m *AmbulanceMutation) RemovedCarcheckinoutIDs() (ids []int) {
	for id := range m.removedcarcheckinout {
		ids = append(ids, id)
	}
	return
}

// CarcheckinoutIDs returns the carcheckinout ids in the mutation.
func (m *AmbulanceMutation) CarcheckinoutIDs() (ids []int) {
	for id := range m.carcheckinout {
		ids = append(ids, id)
	}
	return
}

// ResetCarcheckinout reset all changes of the "carcheckinout" edge.
func (m *AmbulanceMutation) ResetCarcheckinout() {
	m.carcheckinout = nil
	m.removedcarcheckinout = nil
}

// AddAmbulanceIDs adds the ambulance edge to Transport by ids.
func (m *AmbulanceMutation) AddAmbulanceIDs(ids ...int) {
	if m.ambulance == nil {
		m.ambulance = make(map[int]struct{})
	}
	for i := range ids {
		m.ambulance[ids[i]] = struct{}{}
	}
}

// RemoveAmbulanceIDs removes the ambulance edge to Transport by ids.
func (m *AmbulanceMutation) RemoveAmbulanceIDs(ids ...int) {
	if m.removedambulance == nil {
		m.removedambulance = make(map[int]struct{})
	}
	for i := range ids {
		m.removedambulance[ids[i]] = struct{}{}
	}
}

// RemovedAmbulance returns the removed ids of ambulance.
func (m *AmbulanceMutation) RemovedAmbulanceIDs() (ids []int) {
	for id := range m.removedambulance {
		ids = append(ids, id)
	}
	return
}

// AmbulanceIDs returns the ambulance ids in the mutation.
func (m *AmbulanceMutation) AmbulanceIDs() (ids []int) {
	for id := range m.ambulance {
		ids = append(ids, id)
	}
	return
}

// ResetAmbulance reset all changes of the "ambulance" edge.
func (m *AmbulanceMutation) ResetAmbulance() {
	m.ambulance = nil
	m.removedambulance = nil
}

// Op returns the operation name.
func (m *AmbulanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Ambulance).
func (m *AmbulanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AmbulanceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.carregistration != nil {
		fields = append(fields, ambulance.FieldCarregistration)
	}
	if m.registerat != nil {
		fields = append(fields, ambulance.FieldRegisterat)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AmbulanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ambulance.FieldCarregistration:
		return m.Carregistration()
	case ambulance.FieldRegisterat:
		return m.Registerat()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AmbulanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ambulance.FieldCarregistration:
		return m.OldCarregistration(ctx)
	case ambulance.FieldRegisterat:
		return m.OldRegisterat(ctx)
	}
	return nil, fmt.Errorf("unknown Ambulance field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AmbulanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ambulance.FieldCarregistration:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarregistration(v)
		return nil
	case ambulance.FieldRegisterat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterat(v)
		return nil
	}
	return fmt.Errorf("unknown Ambulance field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AmbulanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AmbulanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AmbulanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ambulance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AmbulanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AmbulanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AmbulanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ambulance nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AmbulanceMutation) ResetField(name string) error {
	switch name {
	case ambulance.FieldCarregistration:
		m.ResetCarregistration()
		return nil
	case ambulance.FieldRegisterat:
		m.ResetRegisterat()
		return nil
	}
	return fmt.Errorf("unknown Ambulance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AmbulanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.hasbrand != nil {
		edges = append(edges, ambulance.EdgeHasbrand)
	}
	if m.hasinsurance != nil {
		edges = append(edges, ambulance.EdgeHasinsurance)
	}
	if m.hasstatus != nil {
		edges = append(edges, ambulance.EdgeHasstatus)
	}
	if m.hasuser != nil {
		edges = append(edges, ambulance.EdgeHasuser)
	}
	if m.carinspections != nil {
		edges = append(edges, ambulance.EdgeCarinspections)
	}
	if m.carcheckinout != nil {
		edges = append(edges, ambulance.EdgeCarcheckinout)
	}
	if m.ambulance != nil {
		edges = append(edges, ambulance.EdgeAmbulance)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AmbulanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ambulance.EdgeHasbrand:
		if id := m.hasbrand; id != nil {
			return []ent.Value{*id}
		}
	case ambulance.EdgeHasinsurance:
		if id := m.hasinsurance; id != nil {
			return []ent.Value{*id}
		}
	case ambulance.EdgeHasstatus:
		if id := m.hasstatus; id != nil {
			return []ent.Value{*id}
		}
	case ambulance.EdgeHasuser:
		if id := m.hasuser; id != nil {
			return []ent.Value{*id}
		}
	case ambulance.EdgeCarinspections:
		ids := make([]ent.Value, 0, len(m.carinspections))
		for id := range m.carinspections {
			ids = append(ids, id)
		}
		return ids
	case ambulance.EdgeCarcheckinout:
		ids := make([]ent.Value, 0, len(m.carcheckinout))
		for id := range m.carcheckinout {
			ids = append(ids, id)
		}
		return ids
	case ambulance.EdgeAmbulance:
		ids := make([]ent.Value, 0, len(m.ambulance))
		for id := range m.ambulance {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AmbulanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedcarinspections != nil {
		edges = append(edges, ambulance.EdgeCarinspections)
	}
	if m.removedcarcheckinout != nil {
		edges = append(edges, ambulance.EdgeCarcheckinout)
	}
	if m.removedambulance != nil {
		edges = append(edges, ambulance.EdgeAmbulance)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AmbulanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ambulance.EdgeCarinspections:
		ids := make([]ent.Value, 0, len(m.removedcarinspections))
		for id := range m.removedcarinspections {
			ids = append(ids, id)
		}
		return ids
	case ambulance.EdgeCarcheckinout:
		ids := make([]ent.Value, 0, len(m.removedcarcheckinout))
		for id := range m.removedcarcheckinout {
			ids = append(ids, id)
		}
		return ids
	case ambulance.EdgeAmbulance:
		ids := make([]ent.Value, 0, len(m.removedambulance))
		for id := range m.removedambulance {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AmbulanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedhasbrand {
		edges = append(edges, ambulance.EdgeHasbrand)
	}
	if m.clearedhasinsurance {
		edges = append(edges, ambulance.EdgeHasinsurance)
	}
	if m.clearedhasstatus {
		edges = append(edges, ambulance.EdgeHasstatus)
	}
	if m.clearedhasuser {
		edges = append(edges, ambulance.EdgeHasuser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AmbulanceMutation) EdgeCleared(name string) bool {
	switch name {
	case ambulance.EdgeHasbrand:
		return m.clearedhasbrand
	case ambulance.EdgeHasinsurance:
		return m.clearedhasinsurance
	case ambulance.EdgeHasstatus:
		return m.clearedhasstatus
	case ambulance.EdgeHasuser:
		return m.clearedhasuser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AmbulanceMutation) ClearEdge(name string) error {
	switch name {
	case ambulance.EdgeHasbrand:
		m.ClearHasbrand()
		return nil
	case ambulance.EdgeHasinsurance:
		m.ClearHasinsurance()
		return nil
	case ambulance.EdgeHasstatus:
		m.ClearHasstatus()
		return nil
	case ambulance.EdgeHasuser:
		m.ClearHasuser()
		return nil
	}
	return fmt.Errorf("unknown Ambulance unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AmbulanceMutation) ResetEdge(name string) error {
	switch name {
	case ambulance.EdgeHasbrand:
		m.ResetHasbrand()
		return nil
	case ambulance.EdgeHasinsurance:
		m.ResetHasinsurance()
		return nil
	case ambulance.EdgeHasstatus:
		m.ResetHasstatus()
		return nil
	case ambulance.EdgeHasuser:
		m.ResetHasuser()
		return nil
	case ambulance.EdgeCarinspections:
		m.ResetCarinspections()
		return nil
	case ambulance.EdgeCarcheckinout:
		m.ResetCarcheckinout()
		return nil
	case ambulance.EdgeAmbulance:
		m.ResetAmbulance()
		return nil
	}
	return fmt.Errorf("unknown Ambulance edge %s", name)
}

// CarCheckInOutMutation represents an operation that mutate the CarCheckInOuts
// nodes in the graph.
type CarCheckInOutMutation struct {
	config
	op               Op
	typ              string
	id               *int
	note             *string
	checkIn          *time.Time
	checkOut         *time.Time
	clearedFields    map[string]struct{}
	ambulance        *int
	clearedambulance bool
	name             *int
	clearedname      bool
	purpose          *int
	clearedpurpose   bool
	done             bool
	oldValue         func(context.Context) (*CarCheckInOut, error)
}

var _ ent.Mutation = (*CarCheckInOutMutation)(nil)

// carcheckinoutOption allows to manage the mutation configuration using functional options.
type carcheckinoutOption func(*CarCheckInOutMutation)

// newCarCheckInOutMutation creates new mutation for $n.Name.
func newCarCheckInOutMutation(c config, op Op, opts ...carcheckinoutOption) *CarCheckInOutMutation {
	m := &CarCheckInOutMutation{
		config:        c,
		op:            op,
		typ:           TypeCarCheckInOut,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarCheckInOutID sets the id field of the mutation.
func withCarCheckInOutID(id int) carcheckinoutOption {
	return func(m *CarCheckInOutMutation) {
		var (
			err   error
			once  sync.Once
			value *CarCheckInOut
		)
		m.oldValue = func(ctx context.Context) (*CarCheckInOut, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarCheckInOut.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarCheckInOut sets the old CarCheckInOut of the mutation.
func withCarCheckInOut(node *CarCheckInOut) carcheckinoutOption {
	return func(m *CarCheckInOutMutation) {
		m.oldValue = func(context.Context) (*CarCheckInOut, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarCheckInOutMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarCheckInOutMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CarCheckInOutMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNote sets the note field.
func (m *CarCheckInOutMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the note value in the mutation.
func (m *CarCheckInOutMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old note value of the CarCheckInOut.
// If the CarCheckInOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CarCheckInOutMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNote is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote reset all changes of the "note" field.
func (m *CarCheckInOutMutation) ResetNote() {
	m.note = nil
}

// SetCheckIn sets the checkIn field.
func (m *CarCheckInOutMutation) SetCheckIn(t time.Time) {
	m.checkIn = &t
}

// CheckIn returns the checkIn value in the mutation.
func (m *CarCheckInOutMutation) CheckIn() (r time.Time, exists bool) {
	v := m.checkIn
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckIn returns the old checkIn value of the CarCheckInOut.
// If the CarCheckInOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CarCheckInOutMutation) OldCheckIn(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckIn is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckIn: %w", err)
	}
	return oldValue.CheckIn, nil
}

// ResetCheckIn reset all changes of the "checkIn" field.
func (m *CarCheckInOutMutation) ResetCheckIn() {
	m.checkIn = nil
}

// SetCheckOut sets the checkOut field.
func (m *CarCheckInOutMutation) SetCheckOut(t time.Time) {
	m.checkOut = &t
}

// CheckOut returns the checkOut value in the mutation.
func (m *CarCheckInOutMutation) CheckOut() (r time.Time, exists bool) {
	v := m.checkOut
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckOut returns the old checkOut value of the CarCheckInOut.
// If the CarCheckInOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CarCheckInOutMutation) OldCheckOut(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckOut is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckOut requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckOut: %w", err)
	}
	return oldValue.CheckOut, nil
}

// ResetCheckOut reset all changes of the "checkOut" field.
func (m *CarCheckInOutMutation) ResetCheckOut() {
	m.checkOut = nil
}

// SetAmbulanceID sets the ambulance edge to Ambulance by id.
func (m *CarCheckInOutMutation) SetAmbulanceID(id int) {
	m.ambulance = &id
}

// ClearAmbulance clears the ambulance edge to Ambulance.
func (m *CarCheckInOutMutation) ClearAmbulance() {
	m.clearedambulance = true
}

// AmbulanceCleared returns if the edge ambulance was cleared.
func (m *CarCheckInOutMutation) AmbulanceCleared() bool {
	return m.clearedambulance
}

// AmbulanceID returns the ambulance id in the mutation.
func (m *CarCheckInOutMutation) AmbulanceID() (id int, exists bool) {
	if m.ambulance != nil {
		return *m.ambulance, true
	}
	return
}

// AmbulanceIDs returns the ambulance ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AmbulanceID instead. It exists only for internal usage by the builders.
func (m *CarCheckInOutMutation) AmbulanceIDs() (ids []int) {
	if id := m.ambulance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAmbulance reset all changes of the "ambulance" edge.
func (m *CarCheckInOutMutation) ResetAmbulance() {
	m.ambulance = nil
	m.clearedambulance = false
}

// SetNameID sets the name edge to User by id.
func (m *CarCheckInOutMutation) SetNameID(id int) {
	m.name = &id
}

// ClearName clears the name edge to User.
func (m *CarCheckInOutMutation) ClearName() {
	m.clearedname = true
}

// NameCleared returns if the edge name was cleared.
func (m *CarCheckInOutMutation) NameCleared() bool {
	return m.clearedname
}

// NameID returns the name id in the mutation.
func (m *CarCheckInOutMutation) NameID() (id int, exists bool) {
	if m.name != nil {
		return *m.name, true
	}
	return
}

// NameIDs returns the name ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// NameID instead. It exists only for internal usage by the builders.
func (m *CarCheckInOutMutation) NameIDs() (ids []int) {
	if id := m.name; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetName reset all changes of the "name" edge.
func (m *CarCheckInOutMutation) ResetName() {
	m.name = nil
	m.clearedname = false
}

// SetPurposeID sets the purpose edge to Purpose by id.
func (m *CarCheckInOutMutation) SetPurposeID(id int) {
	m.purpose = &id
}

// ClearPurpose clears the purpose edge to Purpose.
func (m *CarCheckInOutMutation) ClearPurpose() {
	m.clearedpurpose = true
}

// PurposeCleared returns if the edge purpose was cleared.
func (m *CarCheckInOutMutation) PurposeCleared() bool {
	return m.clearedpurpose
}

// PurposeID returns the purpose id in the mutation.
func (m *CarCheckInOutMutation) PurposeID() (id int, exists bool) {
	if m.purpose != nil {
		return *m.purpose, true
	}
	return
}

// PurposeIDs returns the purpose ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PurposeID instead. It exists only for internal usage by the builders.
func (m *CarCheckInOutMutation) PurposeIDs() (ids []int) {
	if id := m.purpose; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPurpose reset all changes of the "purpose" edge.
func (m *CarCheckInOutMutation) ResetPurpose() {
	m.purpose = nil
	m.clearedpurpose = false
}

// Op returns the operation name.
func (m *CarCheckInOutMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CarCheckInOut).
func (m *CarCheckInOutMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CarCheckInOutMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.note != nil {
		fields = append(fields, carcheckinout.FieldNote)
	}
	if m.checkIn != nil {
		fields = append(fields, carcheckinout.FieldCheckIn)
	}
	if m.checkOut != nil {
		fields = append(fields, carcheckinout.FieldCheckOut)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CarCheckInOutMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carcheckinout.FieldNote:
		return m.Note()
	case carcheckinout.FieldCheckIn:
		return m.CheckIn()
	case carcheckinout.FieldCheckOut:
		return m.CheckOut()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CarCheckInOutMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carcheckinout.FieldNote:
		return m.OldNote(ctx)
	case carcheckinout.FieldCheckIn:
		return m.OldCheckIn(ctx)
	case carcheckinout.FieldCheckOut:
		return m.OldCheckOut(ctx)
	}
	return nil, fmt.Errorf("unknown CarCheckInOut field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CarCheckInOutMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carcheckinout.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case carcheckinout.FieldCheckIn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckIn(v)
		return nil
	case carcheckinout.FieldCheckOut:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckOut(v)
		return nil
	}
	return fmt.Errorf("unknown CarCheckInOut field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CarCheckInOutMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CarCheckInOutMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CarCheckInOutMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarCheckInOut numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CarCheckInOutMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CarCheckInOutMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarCheckInOutMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarCheckInOut nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CarCheckInOutMutation) ResetField(name string) error {
	switch name {
	case carcheckinout.FieldNote:
		m.ResetNote()
		return nil
	case carcheckinout.FieldCheckIn:
		m.ResetCheckIn()
		return nil
	case carcheckinout.FieldCheckOut:
		m.ResetCheckOut()
		return nil
	}
	return fmt.Errorf("unknown CarCheckInOut field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CarCheckInOutMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.ambulance != nil {
		edges = append(edges, carcheckinout.EdgeAmbulance)
	}
	if m.name != nil {
		edges = append(edges, carcheckinout.EdgeName)
	}
	if m.purpose != nil {
		edges = append(edges, carcheckinout.EdgePurpose)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CarCheckInOutMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carcheckinout.EdgeAmbulance:
		if id := m.ambulance; id != nil {
			return []ent.Value{*id}
		}
	case carcheckinout.EdgeName:
		if id := m.name; id != nil {
			return []ent.Value{*id}
		}
	case carcheckinout.EdgePurpose:
		if id := m.purpose; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CarCheckInOutMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CarCheckInOutMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CarCheckInOutMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedambulance {
		edges = append(edges, carcheckinout.EdgeAmbulance)
	}
	if m.clearedname {
		edges = append(edges, carcheckinout.EdgeName)
	}
	if m.clearedpurpose {
		edges = append(edges, carcheckinout.EdgePurpose)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CarCheckInOutMutation) EdgeCleared(name string) bool {
	switch name {
	case carcheckinout.EdgeAmbulance:
		return m.clearedambulance
	case carcheckinout.EdgeName:
		return m.clearedname
	case carcheckinout.EdgePurpose:
		return m.clearedpurpose
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CarCheckInOutMutation) ClearEdge(name string) error {
	switch name {
	case carcheckinout.EdgeAmbulance:
		m.ClearAmbulance()
		return nil
	case carcheckinout.EdgeName:
		m.ClearName()
		return nil
	case carcheckinout.EdgePurpose:
		m.ClearPurpose()
		return nil
	}
	return fmt.Errorf("unknown CarCheckInOut unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CarCheckInOutMutation) ResetEdge(name string) error {
	switch name {
	case carcheckinout.EdgeAmbulance:
		m.ResetAmbulance()
		return nil
	case carcheckinout.EdgeName:
		m.ResetName()
		return nil
	case carcheckinout.EdgePurpose:
		m.ResetPurpose()
		return nil
	}
	return fmt.Errorf("unknown CarCheckInOut edge %s", name)
}

// CarInspectionMutation represents an operation that mutate the CarInspections
// nodes in the graph.
type CarInspectionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	datetime                *time.Time
	note                    *string
	clearedFields           map[string]struct{}
	user                    *int
	cleareduser             bool
	ambulance               *int
	clearedambulance        bool
	inspectionresult        *int
	clearedinspectionresult bool
	carrepairrecords        map[int]struct{}
	removedcarrepairrecords map[int]struct{}
	done                    bool
	oldValue                func(context.Context) (*CarInspection, error)
}

var _ ent.Mutation = (*CarInspectionMutation)(nil)

// carinspectionOption allows to manage the mutation configuration using functional options.
type carinspectionOption func(*CarInspectionMutation)

// newCarInspectionMutation creates new mutation for $n.Name.
func newCarInspectionMutation(c config, op Op, opts ...carinspectionOption) *CarInspectionMutation {
	m := &CarInspectionMutation{
		config:        c,
		op:            op,
		typ:           TypeCarInspection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarInspectionID sets the id field of the mutation.
func withCarInspectionID(id int) carinspectionOption {
	return func(m *CarInspectionMutation) {
		var (
			err   error
			once  sync.Once
			value *CarInspection
		)
		m.oldValue = func(ctx context.Context) (*CarInspection, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarInspection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarInspection sets the old CarInspection of the mutation.
func withCarInspection(node *CarInspection) carinspectionOption {
	return func(m *CarInspectionMutation) {
		m.oldValue = func(context.Context) (*CarInspection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarInspectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarInspectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CarInspectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDatetime sets the datetime field.
func (m *CarInspectionMutation) SetDatetime(t time.Time) {
	m.datetime = &t
}

// Datetime returns the datetime value in the mutation.
func (m *CarInspectionMutation) Datetime() (r time.Time, exists bool) {
	v := m.datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetime returns the old datetime value of the CarInspection.
// If the CarInspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CarInspectionMutation) OldDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDatetime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetime: %w", err)
	}
	return oldValue.Datetime, nil
}

// ResetDatetime reset all changes of the "datetime" field.
func (m *CarInspectionMutation) ResetDatetime() {
	m.datetime = nil
}

// SetNote sets the note field.
func (m *CarInspectionMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the note value in the mutation.
func (m *CarInspectionMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old note value of the CarInspection.
// If the CarInspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CarInspectionMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNote is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote reset all changes of the "note" field.
func (m *CarInspectionMutation) ResetNote() {
	m.note = nil
}

// SetUserID sets the user edge to User by id.
func (m *CarInspectionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *CarInspectionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *CarInspectionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *CarInspectionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CarInspectionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *CarInspectionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetAmbulanceID sets the ambulance edge to Ambulance by id.
func (m *CarInspectionMutation) SetAmbulanceID(id int) {
	m.ambulance = &id
}

// ClearAmbulance clears the ambulance edge to Ambulance.
func (m *CarInspectionMutation) ClearAmbulance() {
	m.clearedambulance = true
}

// AmbulanceCleared returns if the edge ambulance was cleared.
func (m *CarInspectionMutation) AmbulanceCleared() bool {
	return m.clearedambulance
}

// AmbulanceID returns the ambulance id in the mutation.
func (m *CarInspectionMutation) AmbulanceID() (id int, exists bool) {
	if m.ambulance != nil {
		return *m.ambulance, true
	}
	return
}

// AmbulanceIDs returns the ambulance ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AmbulanceID instead. It exists only for internal usage by the builders.
func (m *CarInspectionMutation) AmbulanceIDs() (ids []int) {
	if id := m.ambulance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAmbulance reset all changes of the "ambulance" edge.
func (m *CarInspectionMutation) ResetAmbulance() {
	m.ambulance = nil
	m.clearedambulance = false
}

// SetInspectionresultID sets the inspectionresult edge to InspectionResult by id.
func (m *CarInspectionMutation) SetInspectionresultID(id int) {
	m.inspectionresult = &id
}

// ClearInspectionresult clears the inspectionresult edge to InspectionResult.
func (m *CarInspectionMutation) ClearInspectionresult() {
	m.clearedinspectionresult = true
}

// InspectionresultCleared returns if the edge inspectionresult was cleared.
func (m *CarInspectionMutation) InspectionresultCleared() bool {
	return m.clearedinspectionresult
}

// InspectionresultID returns the inspectionresult id in the mutation.
func (m *CarInspectionMutation) InspectionresultID() (id int, exists bool) {
	if m.inspectionresult != nil {
		return *m.inspectionresult, true
	}
	return
}

// InspectionresultIDs returns the inspectionresult ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// InspectionresultID instead. It exists only for internal usage by the builders.
func (m *CarInspectionMutation) InspectionresultIDs() (ids []int) {
	if id := m.inspectionresult; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInspectionresult reset all changes of the "inspectionresult" edge.
func (m *CarInspectionMutation) ResetInspectionresult() {
	m.inspectionresult = nil
	m.clearedinspectionresult = false
}

// AddCarrepairrecordIDs adds the carrepairrecords edge to CarRepairrecord by ids.
func (m *CarInspectionMutation) AddCarrepairrecordIDs(ids ...int) {
	if m.carrepairrecords == nil {
		m.carrepairrecords = make(map[int]struct{})
	}
	for i := range ids {
		m.carrepairrecords[ids[i]] = struct{}{}
	}
}

// RemoveCarrepairrecordIDs removes the carrepairrecords edge to CarRepairrecord by ids.
func (m *CarInspectionMutation) RemoveCarrepairrecordIDs(ids ...int) {
	if m.removedcarrepairrecords == nil {
		m.removedcarrepairrecords = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcarrepairrecords[ids[i]] = struct{}{}
	}
}

// RemovedCarrepairrecords returns the removed ids of carrepairrecords.
func (m *CarInspectionMutation) RemovedCarrepairrecordsIDs() (ids []int) {
	for id := range m.removedcarrepairrecords {
		ids = append(ids, id)
	}
	return
}

// CarrepairrecordsIDs returns the carrepairrecords ids in the mutation.
func (m *CarInspectionMutation) CarrepairrecordsIDs() (ids []int) {
	for id := range m.carrepairrecords {
		ids = append(ids, id)
	}
	return
}

// ResetCarrepairrecords reset all changes of the "carrepairrecords" edge.
func (m *CarInspectionMutation) ResetCarrepairrecords() {
	m.carrepairrecords = nil
	m.removedcarrepairrecords = nil
}

// Op returns the operation name.
func (m *CarInspectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CarInspection).
func (m *CarInspectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CarInspectionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.datetime != nil {
		fields = append(fields, carinspection.FieldDatetime)
	}
	if m.note != nil {
		fields = append(fields, carinspection.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CarInspectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carinspection.FieldDatetime:
		return m.Datetime()
	case carinspection.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CarInspectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carinspection.FieldDatetime:
		return m.OldDatetime(ctx)
	case carinspection.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown CarInspection field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CarInspectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carinspection.FieldDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetime(v)
		return nil
	case carinspection.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown CarInspection field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CarInspectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CarInspectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CarInspectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarInspection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CarInspectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CarInspectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarInspectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarInspection nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CarInspectionMutation) ResetField(name string) error {
	switch name {
	case carinspection.FieldDatetime:
		m.ResetDatetime()
		return nil
	case carinspection.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown CarInspection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CarInspectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, carinspection.EdgeUser)
	}
	if m.ambulance != nil {
		edges = append(edges, carinspection.EdgeAmbulance)
	}
	if m.inspectionresult != nil {
		edges = append(edges, carinspection.EdgeInspectionresult)
	}
	if m.carrepairrecords != nil {
		edges = append(edges, carinspection.EdgeCarrepairrecords)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CarInspectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carinspection.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case carinspection.EdgeAmbulance:
		if id := m.ambulance; id != nil {
			return []ent.Value{*id}
		}
	case carinspection.EdgeInspectionresult:
		if id := m.inspectionresult; id != nil {
			return []ent.Value{*id}
		}
	case carinspection.EdgeCarrepairrecords:
		ids := make([]ent.Value, 0, len(m.carrepairrecords))
		for id := range m.carrepairrecords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CarInspectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcarrepairrecords != nil {
		edges = append(edges, carinspection.EdgeCarrepairrecords)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CarInspectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carinspection.EdgeCarrepairrecords:
		ids := make([]ent.Value, 0, len(m.removedcarrepairrecords))
		for id := range m.removedcarrepairrecords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CarInspectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, carinspection.EdgeUser)
	}
	if m.clearedambulance {
		edges = append(edges, carinspection.EdgeAmbulance)
	}
	if m.clearedinspectionresult {
		edges = append(edges, carinspection.EdgeInspectionresult)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CarInspectionMutation) EdgeCleared(name string) bool {
	switch name {
	case carinspection.EdgeUser:
		return m.cleareduser
	case carinspection.EdgeAmbulance:
		return m.clearedambulance
	case carinspection.EdgeInspectionresult:
		return m.clearedinspectionresult
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CarInspectionMutation) ClearEdge(name string) error {
	switch name {
	case carinspection.EdgeUser:
		m.ClearUser()
		return nil
	case carinspection.EdgeAmbulance:
		m.ClearAmbulance()
		return nil
	case carinspection.EdgeInspectionresult:
		m.ClearInspectionresult()
		return nil
	}
	return fmt.Errorf("unknown CarInspection unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CarInspectionMutation) ResetEdge(name string) error {
	switch name {
	case carinspection.EdgeUser:
		m.ResetUser()
		return nil
	case carinspection.EdgeAmbulance:
		m.ResetAmbulance()
		return nil
	case carinspection.EdgeInspectionresult:
		m.ResetInspectionresult()
		return nil
	case carinspection.EdgeCarrepairrecords:
		m.ResetCarrepairrecords()
		return nil
	}
	return fmt.Errorf("unknown CarInspection edge %s", name)
}

// CarRepairrecordMutation represents an operation that mutate the CarRepairrecords
// nodes in the graph.
type CarRepairrecordMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	datetime             *time.Time
	clearedFields        map[string]struct{}
	keeper               *int
	clearedkeeper        bool
	user                 *int
	cleareduser          bool
	carinspection        *int
	clearedcarinspection bool
	done                 bool
	oldValue             func(context.Context) (*CarRepairrecord, error)
}

var _ ent.Mutation = (*CarRepairrecordMutation)(nil)

// carrepairrecordOption allows to manage the mutation configuration using functional options.
type carrepairrecordOption func(*CarRepairrecordMutation)

// newCarRepairrecordMutation creates new mutation for $n.Name.
func newCarRepairrecordMutation(c config, op Op, opts ...carrepairrecordOption) *CarRepairrecordMutation {
	m := &CarRepairrecordMutation{
		config:        c,
		op:            op,
		typ:           TypeCarRepairrecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarRepairrecordID sets the id field of the mutation.
func withCarRepairrecordID(id int) carrepairrecordOption {
	return func(m *CarRepairrecordMutation) {
		var (
			err   error
			once  sync.Once
			value *CarRepairrecord
		)
		m.oldValue = func(ctx context.Context) (*CarRepairrecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarRepairrecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarRepairrecord sets the old CarRepairrecord of the mutation.
func withCarRepairrecord(node *CarRepairrecord) carrepairrecordOption {
	return func(m *CarRepairrecordMutation) {
		m.oldValue = func(context.Context) (*CarRepairrecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarRepairrecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarRepairrecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CarRepairrecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDatetime sets the datetime field.
func (m *CarRepairrecordMutation) SetDatetime(t time.Time) {
	m.datetime = &t
}

// Datetime returns the datetime value in the mutation.
func (m *CarRepairrecordMutation) Datetime() (r time.Time, exists bool) {
	v := m.datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetime returns the old datetime value of the CarRepairrecord.
// If the CarRepairrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CarRepairrecordMutation) OldDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDatetime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetime: %w", err)
	}
	return oldValue.Datetime, nil
}

// ResetDatetime reset all changes of the "datetime" field.
func (m *CarRepairrecordMutation) ResetDatetime() {
	m.datetime = nil
}

// SetKeeperID sets the keeper edge to Repairing by id.
func (m *CarRepairrecordMutation) SetKeeperID(id int) {
	m.keeper = &id
}

// ClearKeeper clears the keeper edge to Repairing.
func (m *CarRepairrecordMutation) ClearKeeper() {
	m.clearedkeeper = true
}

// KeeperCleared returns if the edge keeper was cleared.
func (m *CarRepairrecordMutation) KeeperCleared() bool {
	return m.clearedkeeper
}

// KeeperID returns the keeper id in the mutation.
func (m *CarRepairrecordMutation) KeeperID() (id int, exists bool) {
	if m.keeper != nil {
		return *m.keeper, true
	}
	return
}

// KeeperIDs returns the keeper ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// KeeperID instead. It exists only for internal usage by the builders.
func (m *CarRepairrecordMutation) KeeperIDs() (ids []int) {
	if id := m.keeper; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKeeper reset all changes of the "keeper" edge.
func (m *CarRepairrecordMutation) ResetKeeper() {
	m.keeper = nil
	m.clearedkeeper = false
}

// SetUserID sets the user edge to User by id.
func (m *CarRepairrecordMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *CarRepairrecordMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *CarRepairrecordMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *CarRepairrecordMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CarRepairrecordMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *CarRepairrecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetCarinspectionID sets the carinspection edge to CarInspection by id.
func (m *CarRepairrecordMutation) SetCarinspectionID(id int) {
	m.carinspection = &id
}

// ClearCarinspection clears the carinspection edge to CarInspection.
func (m *CarRepairrecordMutation) ClearCarinspection() {
	m.clearedcarinspection = true
}

// CarinspectionCleared returns if the edge carinspection was cleared.
func (m *CarRepairrecordMutation) CarinspectionCleared() bool {
	return m.clearedcarinspection
}

// CarinspectionID returns the carinspection id in the mutation.
func (m *CarRepairrecordMutation) CarinspectionID() (id int, exists bool) {
	if m.carinspection != nil {
		return *m.carinspection, true
	}
	return
}

// CarinspectionIDs returns the carinspection ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CarinspectionID instead. It exists only for internal usage by the builders.
func (m *CarRepairrecordMutation) CarinspectionIDs() (ids []int) {
	if id := m.carinspection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarinspection reset all changes of the "carinspection" edge.
func (m *CarRepairrecordMutation) ResetCarinspection() {
	m.carinspection = nil
	m.clearedcarinspection = false
}

// Op returns the operation name.
func (m *CarRepairrecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CarRepairrecord).
func (m *CarRepairrecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CarRepairrecordMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.datetime != nil {
		fields = append(fields, carrepairrecord.FieldDatetime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CarRepairrecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrepairrecord.FieldDatetime:
		return m.Datetime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CarRepairrecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrepairrecord.FieldDatetime:
		return m.OldDatetime(ctx)
	}
	return nil, fmt.Errorf("unknown CarRepairrecord field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CarRepairrecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrepairrecord.FieldDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetime(v)
		return nil
	}
	return fmt.Errorf("unknown CarRepairrecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CarRepairrecordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CarRepairrecordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CarRepairrecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarRepairrecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CarRepairrecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CarRepairrecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarRepairrecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarRepairrecord nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CarRepairrecordMutation) ResetField(name string) error {
	switch name {
	case carrepairrecord.FieldDatetime:
		m.ResetDatetime()
		return nil
	}
	return fmt.Errorf("unknown CarRepairrecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CarRepairrecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.keeper != nil {
		edges = append(edges, carrepairrecord.EdgeKeeper)
	}
	if m.user != nil {
		edges = append(edges, carrepairrecord.EdgeUser)
	}
	if m.carinspection != nil {
		edges = append(edges, carrepairrecord.EdgeCarinspection)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CarRepairrecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrepairrecord.EdgeKeeper:
		if id := m.keeper; id != nil {
			return []ent.Value{*id}
		}
	case carrepairrecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case carrepairrecord.EdgeCarinspection:
		if id := m.carinspection; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CarRepairrecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CarRepairrecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CarRepairrecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedkeeper {
		edges = append(edges, carrepairrecord.EdgeKeeper)
	}
	if m.cleareduser {
		edges = append(edges, carrepairrecord.EdgeUser)
	}
	if m.clearedcarinspection {
		edges = append(edges, carrepairrecord.EdgeCarinspection)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CarRepairrecordMutation) EdgeCleared(name string) bool {
	switch name {
	case carrepairrecord.EdgeKeeper:
		return m.clearedkeeper
	case carrepairrecord.EdgeUser:
		return m.cleareduser
	case carrepairrecord.EdgeCarinspection:
		return m.clearedcarinspection
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CarRepairrecordMutation) ClearEdge(name string) error {
	switch name {
	case carrepairrecord.EdgeKeeper:
		m.ClearKeeper()
		return nil
	case carrepairrecord.EdgeUser:
		m.ClearUser()
		return nil
	case carrepairrecord.EdgeCarinspection:
		m.ClearCarinspection()
		return nil
	}
	return fmt.Errorf("unknown CarRepairrecord unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CarRepairrecordMutation) ResetEdge(name string) error {
	switch name {
	case carrepairrecord.EdgeKeeper:
		m.ResetKeeper()
		return nil
	case carrepairrecord.EdgeUser:
		m.ResetUser()
		return nil
	case carrepairrecord.EdgeCarinspection:
		m.ResetCarinspection()
		return nil
	}
	return fmt.Errorf("unknown CarRepairrecord edge %s", name)
}

// CarbrandMutation represents an operation that mutate the Carbrands
// nodes in the graph.
type CarbrandMutation struct {
	config
	op             Op
	typ            string
	id             *int
	brand          *string
	clearedFields  map[string]struct{}
	brandof        map[int]struct{}
	removedbrandof map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Carbrand, error)
}

var _ ent.Mutation = (*CarbrandMutation)(nil)

// carbrandOption allows to manage the mutation configuration using functional options.
type carbrandOption func(*CarbrandMutation)

// newCarbrandMutation creates new mutation for $n.Name.
func newCarbrandMutation(c config, op Op, opts ...carbrandOption) *CarbrandMutation {
	m := &CarbrandMutation{
		config:        c,
		op:            op,
		typ:           TypeCarbrand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarbrandID sets the id field of the mutation.
func withCarbrandID(id int) carbrandOption {
	return func(m *CarbrandMutation) {
		var (
			err   error
			once  sync.Once
			value *Carbrand
		)
		m.oldValue = func(ctx context.Context) (*Carbrand, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Carbrand.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarbrand sets the old Carbrand of the mutation.
func withCarbrand(node *Carbrand) carbrandOption {
	return func(m *CarbrandMutation) {
		m.oldValue = func(context.Context) (*Carbrand, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarbrandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarbrandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CarbrandMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBrand sets the brand field.
func (m *CarbrandMutation) SetBrand(s string) {
	m.brand = &s
}

// Brand returns the brand value in the mutation.
func (m *CarbrandMutation) Brand() (r string, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old brand value of the Carbrand.
// If the Carbrand object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CarbrandMutation) OldBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBrand is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// ResetBrand reset all changes of the "brand" field.
func (m *CarbrandMutation) ResetBrand() {
	m.brand = nil
}

// AddBrandofIDs adds the brandof edge to Ambulance by ids.
func (m *CarbrandMutation) AddBrandofIDs(ids ...int) {
	if m.brandof == nil {
		m.brandof = make(map[int]struct{})
	}
	for i := range ids {
		m.brandof[ids[i]] = struct{}{}
	}
}

// RemoveBrandofIDs removes the brandof edge to Ambulance by ids.
func (m *CarbrandMutation) RemoveBrandofIDs(ids ...int) {
	if m.removedbrandof == nil {
		m.removedbrandof = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbrandof[ids[i]] = struct{}{}
	}
}

// RemovedBrandof returns the removed ids of brandof.
func (m *CarbrandMutation) RemovedBrandofIDs() (ids []int) {
	for id := range m.removedbrandof {
		ids = append(ids, id)
	}
	return
}

// BrandofIDs returns the brandof ids in the mutation.
func (m *CarbrandMutation) BrandofIDs() (ids []int) {
	for id := range m.brandof {
		ids = append(ids, id)
	}
	return
}

// ResetBrandof reset all changes of the "brandof" edge.
func (m *CarbrandMutation) ResetBrandof() {
	m.brandof = nil
	m.removedbrandof = nil
}

// Op returns the operation name.
func (m *CarbrandMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Carbrand).
func (m *CarbrandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CarbrandMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.brand != nil {
		fields = append(fields, carbrand.FieldBrand)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CarbrandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carbrand.FieldBrand:
		return m.Brand()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CarbrandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carbrand.FieldBrand:
		return m.OldBrand(ctx)
	}
	return nil, fmt.Errorf("unknown Carbrand field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CarbrandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carbrand.FieldBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	}
	return fmt.Errorf("unknown Carbrand field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CarbrandMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CarbrandMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CarbrandMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Carbrand numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CarbrandMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CarbrandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarbrandMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Carbrand nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CarbrandMutation) ResetField(name string) error {
	switch name {
	case carbrand.FieldBrand:
		m.ResetBrand()
		return nil
	}
	return fmt.Errorf("unknown Carbrand field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CarbrandMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.brandof != nil {
		edges = append(edges, carbrand.EdgeBrandof)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CarbrandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carbrand.EdgeBrandof:
		ids := make([]ent.Value, 0, len(m.brandof))
		for id := range m.brandof {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CarbrandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbrandof != nil {
		edges = append(edges, carbrand.EdgeBrandof)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CarbrandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carbrand.EdgeBrandof:
		ids := make([]ent.Value, 0, len(m.removedbrandof))
		for id := range m.removedbrandof {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CarbrandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CarbrandMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CarbrandMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Carbrand unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CarbrandMutation) ResetEdge(name string) error {
	switch name {
	case carbrand.EdgeBrandof:
		m.ResetBrandof()
		return nil
	}
	return fmt.Errorf("unknown Carbrand edge %s", name)
}

// CarregisterMutation represents an operation that mutate the Carregisters
// nodes in the graph.
type CarregisterMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Carregister, error)
}

var _ ent.Mutation = (*CarregisterMutation)(nil)

// carregisterOption allows to manage the mutation configuration using functional options.
type carregisterOption func(*CarregisterMutation)

// newCarregisterMutation creates new mutation for $n.Name.
func newCarregisterMutation(c config, op Op, opts ...carregisterOption) *CarregisterMutation {
	m := &CarregisterMutation{
		config:        c,
		op:            op,
		typ:           TypeCarregister,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarregisterID sets the id field of the mutation.
func withCarregisterID(id int) carregisterOption {
	return func(m *CarregisterMutation) {
		var (
			err   error
			once  sync.Once
			value *Carregister
		)
		m.oldValue = func(ctx context.Context) (*Carregister, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Carregister.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarregister sets the old Carregister of the mutation.
func withCarregister(node *Carregister) carregisterOption {
	return func(m *CarregisterMutation) {
		m.oldValue = func(context.Context) (*Carregister, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarregisterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarregisterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CarregisterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *CarregisterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Carregister).
func (m *CarregisterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CarregisterMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CarregisterMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CarregisterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Carregister field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CarregisterMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Carregister field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CarregisterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CarregisterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CarregisterMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Carregister numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CarregisterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CarregisterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarregisterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Carregister nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CarregisterMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Carregister field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CarregisterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CarregisterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CarregisterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CarregisterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CarregisterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CarregisterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CarregisterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Carregister unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CarregisterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Carregister edge %s", name)
}

// CarserviceMutation represents an operation that mutate the Carservices
// nodes in the graph.
type CarserviceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	customer        *string
	location        *string
	information     *string
	_Datetime       *time.Time
	clearedFields   map[string]struct{}
	userid          *int
	cleareduserid   bool
	disid           *int
	cleareddisid    bool
	urgentid        *int
	clearedurgentid bool
	done            bool
	oldValue        func(context.Context) (*Carservice, error)
}

var _ ent.Mutation = (*CarserviceMutation)(nil)

// carserviceOption allows to manage the mutation configuration using functional options.
type carserviceOption func(*CarserviceMutation)

// newCarserviceMutation creates new mutation for $n.Name.
func newCarserviceMutation(c config, op Op, opts ...carserviceOption) *CarserviceMutation {
	m := &CarserviceMutation{
		config:        c,
		op:            op,
		typ:           TypeCarservice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarserviceID sets the id field of the mutation.
func withCarserviceID(id int) carserviceOption {
	return func(m *CarserviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Carservice
		)
		m.oldValue = func(ctx context.Context) (*Carservice, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Carservice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarservice sets the old Carservice of the mutation.
func withCarservice(node *Carservice) carserviceOption {
	return func(m *CarserviceMutation) {
		m.oldValue = func(context.Context) (*Carservice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarserviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarserviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CarserviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCustomer sets the customer field.
func (m *CarserviceMutation) SetCustomer(s string) {
	m.customer = &s
}

// Customer returns the customer value in the mutation.
func (m *CarserviceMutation) Customer() (r string, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomer returns the old customer value of the Carservice.
// If the Carservice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CarserviceMutation) OldCustomer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCustomer is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCustomer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomer: %w", err)
	}
	return oldValue.Customer, nil
}

// ResetCustomer reset all changes of the "customer" field.
func (m *CarserviceMutation) ResetCustomer() {
	m.customer = nil
}

// SetLocation sets the location field.
func (m *CarserviceMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the location value in the mutation.
func (m *CarserviceMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old location value of the Carservice.
// If the Carservice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CarserviceMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLocation is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation reset all changes of the "location" field.
func (m *CarserviceMutation) ResetLocation() {
	m.location = nil
}

// SetInformation sets the information field.
func (m *CarserviceMutation) SetInformation(s string) {
	m.information = &s
}

// Information returns the information value in the mutation.
func (m *CarserviceMutation) Information() (r string, exists bool) {
	v := m.information
	if v == nil {
		return
	}
	return *v, true
}

// OldInformation returns the old information value of the Carservice.
// If the Carservice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CarserviceMutation) OldInformation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInformation is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInformation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInformation: %w", err)
	}
	return oldValue.Information, nil
}

// ResetInformation reset all changes of the "information" field.
func (m *CarserviceMutation) ResetInformation() {
	m.information = nil
}

// SetDatetime sets the Datetime field.
func (m *CarserviceMutation) SetDatetime(t time.Time) {
	m._Datetime = &t
}

// Datetime returns the Datetime value in the mutation.
func (m *CarserviceMutation) Datetime() (r time.Time, exists bool) {
	v := m._Datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetime returns the old Datetime value of the Carservice.
// If the Carservice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CarserviceMutation) OldDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDatetime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetime: %w", err)
	}
	return oldValue.Datetime, nil
}

// ResetDatetime reset all changes of the "Datetime" field.
func (m *CarserviceMutation) ResetDatetime() {
	m._Datetime = nil
}

// SetUseridID sets the userid edge to User by id.
func (m *CarserviceMutation) SetUseridID(id int) {
	m.userid = &id
}

// ClearUserid clears the userid edge to User.
func (m *CarserviceMutation) ClearUserid() {
	m.cleareduserid = true
}

// UseridCleared returns if the edge userid was cleared.
func (m *CarserviceMutation) UseridCleared() bool {
	return m.cleareduserid
}

// UseridID returns the userid id in the mutation.
func (m *CarserviceMutation) UseridID() (id int, exists bool) {
	if m.userid != nil {
		return *m.userid, true
	}
	return
}

// UseridIDs returns the userid ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UseridID instead. It exists only for internal usage by the builders.
func (m *CarserviceMutation) UseridIDs() (ids []int) {
	if id := m.userid; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserid reset all changes of the "userid" edge.
func (m *CarserviceMutation) ResetUserid() {
	m.userid = nil
	m.cleareduserid = false
}

// SetDisidID sets the disid edge to Distance by id.
func (m *CarserviceMutation) SetDisidID(id int) {
	m.disid = &id
}

// ClearDisid clears the disid edge to Distance.
func (m *CarserviceMutation) ClearDisid() {
	m.cleareddisid = true
}

// DisidCleared returns if the edge disid was cleared.
func (m *CarserviceMutation) DisidCleared() bool {
	return m.cleareddisid
}

// DisidID returns the disid id in the mutation.
func (m *CarserviceMutation) DisidID() (id int, exists bool) {
	if m.disid != nil {
		return *m.disid, true
	}
	return
}

// DisidIDs returns the disid ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DisidID instead. It exists only for internal usage by the builders.
func (m *CarserviceMutation) DisidIDs() (ids []int) {
	if id := m.disid; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDisid reset all changes of the "disid" edge.
func (m *CarserviceMutation) ResetDisid() {
	m.disid = nil
	m.cleareddisid = false
}

// SetUrgentidID sets the urgentid edge to Urgent by id.
func (m *CarserviceMutation) SetUrgentidID(id int) {
	m.urgentid = &id
}

// ClearUrgentid clears the urgentid edge to Urgent.
func (m *CarserviceMutation) ClearUrgentid() {
	m.clearedurgentid = true
}

// UrgentidCleared returns if the edge urgentid was cleared.
func (m *CarserviceMutation) UrgentidCleared() bool {
	return m.clearedurgentid
}

// UrgentidID returns the urgentid id in the mutation.
func (m *CarserviceMutation) UrgentidID() (id int, exists bool) {
	if m.urgentid != nil {
		return *m.urgentid, true
	}
	return
}

// UrgentidIDs returns the urgentid ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UrgentidID instead. It exists only for internal usage by the builders.
func (m *CarserviceMutation) UrgentidIDs() (ids []int) {
	if id := m.urgentid; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUrgentid reset all changes of the "urgentid" edge.
func (m *CarserviceMutation) ResetUrgentid() {
	m.urgentid = nil
	m.clearedurgentid = false
}

// Op returns the operation name.
func (m *CarserviceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Carservice).
func (m *CarserviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CarserviceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.customer != nil {
		fields = append(fields, carservice.FieldCustomer)
	}
	if m.location != nil {
		fields = append(fields, carservice.FieldLocation)
	}
	if m.information != nil {
		fields = append(fields, carservice.FieldInformation)
	}
	if m._Datetime != nil {
		fields = append(fields, carservice.FieldDatetime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CarserviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carservice.FieldCustomer:
		return m.Customer()
	case carservice.FieldLocation:
		return m.Location()
	case carservice.FieldInformation:
		return m.Information()
	case carservice.FieldDatetime:
		return m.Datetime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CarserviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carservice.FieldCustomer:
		return m.OldCustomer(ctx)
	case carservice.FieldLocation:
		return m.OldLocation(ctx)
	case carservice.FieldInformation:
		return m.OldInformation(ctx)
	case carservice.FieldDatetime:
		return m.OldDatetime(ctx)
	}
	return nil, fmt.Errorf("unknown Carservice field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CarserviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carservice.FieldCustomer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomer(v)
		return nil
	case carservice.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case carservice.FieldInformation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInformation(v)
		return nil
	case carservice.FieldDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetime(v)
		return nil
	}
	return fmt.Errorf("unknown Carservice field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CarserviceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CarserviceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CarserviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Carservice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CarserviceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CarserviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarserviceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Carservice nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CarserviceMutation) ResetField(name string) error {
	switch name {
	case carservice.FieldCustomer:
		m.ResetCustomer()
		return nil
	case carservice.FieldLocation:
		m.ResetLocation()
		return nil
	case carservice.FieldInformation:
		m.ResetInformation()
		return nil
	case carservice.FieldDatetime:
		m.ResetDatetime()
		return nil
	}
	return fmt.Errorf("unknown Carservice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CarserviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.userid != nil {
		edges = append(edges, carservice.EdgeUserid)
	}
	if m.disid != nil {
		edges = append(edges, carservice.EdgeDisid)
	}
	if m.urgentid != nil {
		edges = append(edges, carservice.EdgeUrgentid)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CarserviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carservice.EdgeUserid:
		if id := m.userid; id != nil {
			return []ent.Value{*id}
		}
	case carservice.EdgeDisid:
		if id := m.disid; id != nil {
			return []ent.Value{*id}
		}
	case carservice.EdgeUrgentid:
		if id := m.urgentid; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CarserviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CarserviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CarserviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduserid {
		edges = append(edges, carservice.EdgeUserid)
	}
	if m.cleareddisid {
		edges = append(edges, carservice.EdgeDisid)
	}
	if m.clearedurgentid {
		edges = append(edges, carservice.EdgeUrgentid)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CarserviceMutation) EdgeCleared(name string) bool {
	switch name {
	case carservice.EdgeUserid:
		return m.cleareduserid
	case carservice.EdgeDisid:
		return m.cleareddisid
	case carservice.EdgeUrgentid:
		return m.clearedurgentid
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CarserviceMutation) ClearEdge(name string) error {
	switch name {
	case carservice.EdgeUserid:
		m.ClearUserid()
		return nil
	case carservice.EdgeDisid:
		m.ClearDisid()
		return nil
	case carservice.EdgeUrgentid:
		m.ClearUrgentid()
		return nil
	}
	return fmt.Errorf("unknown Carservice unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CarserviceMutation) ResetEdge(name string) error {
	switch name {
	case carservice.EdgeUserid:
		m.ResetUserid()
		return nil
	case carservice.EdgeDisid:
		m.ResetDisid()
		return nil
	case carservice.EdgeUrgentid:
		m.ResetUrgentid()
		return nil
	}
	return fmt.Errorf("unknown Carservice edge %s", name)
}

// DeliverMutation represents an operation that mutate the Delivers
// nodes in the graph.
type DeliverMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Deliver, error)
}

var _ ent.Mutation = (*DeliverMutation)(nil)

// deliverOption allows to manage the mutation configuration using functional options.
type deliverOption func(*DeliverMutation)

// newDeliverMutation creates new mutation for $n.Name.
func newDeliverMutation(c config, op Op, opts ...deliverOption) *DeliverMutation {
	m := &DeliverMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliver,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliverID sets the id field of the mutation.
func withDeliverID(id int) deliverOption {
	return func(m *DeliverMutation) {
		var (
			err   error
			once  sync.Once
			value *Deliver
		)
		m.oldValue = func(ctx context.Context) (*Deliver, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Deliver.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliver sets the old Deliver of the mutation.
func withDeliver(node *Deliver) deliverOption {
	return func(m *DeliverMutation) {
		m.oldValue = func(context.Context) (*Deliver, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliverMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliverMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DeliverMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *DeliverMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Deliver).
func (m *DeliverMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DeliverMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DeliverMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DeliverMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Deliver field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DeliverMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Deliver field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DeliverMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DeliverMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DeliverMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Deliver numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DeliverMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DeliverMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliverMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Deliver nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DeliverMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Deliver field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DeliverMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DeliverMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DeliverMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DeliverMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DeliverMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DeliverMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DeliverMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Deliver unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DeliverMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Deliver edge %s", name)
}

// DistanceMutation represents an operation that mutate the Distances
// nodes in the graph.
type DistanceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Distance     *string
	clearedFields map[string]struct{}
	disid         map[int]struct{}
	removeddisid  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Distance, error)
}

var _ ent.Mutation = (*DistanceMutation)(nil)

// distanceOption allows to manage the mutation configuration using functional options.
type distanceOption func(*DistanceMutation)

// newDistanceMutation creates new mutation for $n.Name.
func newDistanceMutation(c config, op Op, opts ...distanceOption) *DistanceMutation {
	m := &DistanceMutation{
		config:        c,
		op:            op,
		typ:           TypeDistance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDistanceID sets the id field of the mutation.
func withDistanceID(id int) distanceOption {
	return func(m *DistanceMutation) {
		var (
			err   error
			once  sync.Once
			value *Distance
		)
		m.oldValue = func(ctx context.Context) (*Distance, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Distance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDistance sets the old Distance of the mutation.
func withDistance(node *Distance) distanceOption {
	return func(m *DistanceMutation) {
		m.oldValue = func(context.Context) (*Distance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DistanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DistanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DistanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDistance sets the Distance field.
func (m *DistanceMutation) SetDistance(s string) {
	m._Distance = &s
}

// Distance returns the Distance value in the mutation.
func (m *DistanceMutation) Distance() (r string, exists bool) {
	v := m._Distance
	if v == nil {
		return
	}
	return *v, true
}

// OldDistance returns the old Distance value of the Distance.
// If the Distance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DistanceMutation) OldDistance(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistance is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistance: %w", err)
	}
	return oldValue.Distance, nil
}

// ResetDistance reset all changes of the "Distance" field.
func (m *DistanceMutation) ResetDistance() {
	m._Distance = nil
}

// AddDisidIDs adds the disid edge to Carservice by ids.
func (m *DistanceMutation) AddDisidIDs(ids ...int) {
	if m.disid == nil {
		m.disid = make(map[int]struct{})
	}
	for i := range ids {
		m.disid[ids[i]] = struct{}{}
	}
}

// RemoveDisidIDs removes the disid edge to Carservice by ids.
func (m *DistanceMutation) RemoveDisidIDs(ids ...int) {
	if m.removeddisid == nil {
		m.removeddisid = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddisid[ids[i]] = struct{}{}
	}
}

// RemovedDisid returns the removed ids of disid.
func (m *DistanceMutation) RemovedDisidIDs() (ids []int) {
	for id := range m.removeddisid {
		ids = append(ids, id)
	}
	return
}

// DisidIDs returns the disid ids in the mutation.
func (m *DistanceMutation) DisidIDs() (ids []int) {
	for id := range m.disid {
		ids = append(ids, id)
	}
	return
}

// ResetDisid reset all changes of the "disid" edge.
func (m *DistanceMutation) ResetDisid() {
	m.disid = nil
	m.removeddisid = nil
}

// Op returns the operation name.
func (m *DistanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Distance).
func (m *DistanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DistanceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Distance != nil {
		fields = append(fields, distance.FieldDistance)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DistanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case distance.FieldDistance:
		return m.Distance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DistanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case distance.FieldDistance:
		return m.OldDistance(ctx)
	}
	return nil, fmt.Errorf("unknown Distance field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DistanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case distance.FieldDistance:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistance(v)
		return nil
	}
	return fmt.Errorf("unknown Distance field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DistanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DistanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DistanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Distance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DistanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DistanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DistanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Distance nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DistanceMutation) ResetField(name string) error {
	switch name {
	case distance.FieldDistance:
		m.ResetDistance()
		return nil
	}
	return fmt.Errorf("unknown Distance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DistanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.disid != nil {
		edges = append(edges, distance.EdgeDisid)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DistanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case distance.EdgeDisid:
		ids := make([]ent.Value, 0, len(m.disid))
		for id := range m.disid {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DistanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddisid != nil {
		edges = append(edges, distance.EdgeDisid)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DistanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case distance.EdgeDisid:
		ids := make([]ent.Value, 0, len(m.removeddisid))
		for id := range m.removeddisid {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DistanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DistanceMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DistanceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Distance unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DistanceMutation) ResetEdge(name string) error {
	switch name {
	case distance.EdgeDisid:
		m.ResetDisid()
		return nil
	}
	return fmt.Errorf("unknown Distance edge %s", name)
}

// InspectionResultMutation represents an operation that mutate the InspectionResults
// nodes in the graph.
type InspectionResultMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	result_name           *string
	clearedFields         map[string]struct{}
	carinspections        map[int]struct{}
	removedcarinspections map[int]struct{}
	statusof              map[int]struct{}
	removedstatusof       map[int]struct{}
	jobposition           *int
	clearedjobposition    bool
	done                  bool
	oldValue              func(context.Context) (*InspectionResult, error)
}

var _ ent.Mutation = (*InspectionResultMutation)(nil)

// inspectionresultOption allows to manage the mutation configuration using functional options.
type inspectionresultOption func(*InspectionResultMutation)

// newInspectionResultMutation creates new mutation for $n.Name.
func newInspectionResultMutation(c config, op Op, opts ...inspectionresultOption) *InspectionResultMutation {
	m := &InspectionResultMutation{
		config:        c,
		op:            op,
		typ:           TypeInspectionResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInspectionResultID sets the id field of the mutation.
func withInspectionResultID(id int) inspectionresultOption {
	return func(m *InspectionResultMutation) {
		var (
			err   error
			once  sync.Once
			value *InspectionResult
		)
		m.oldValue = func(ctx context.Context) (*InspectionResult, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InspectionResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInspectionResult sets the old InspectionResult of the mutation.
func withInspectionResult(node *InspectionResult) inspectionresultOption {
	return func(m *InspectionResultMutation) {
		m.oldValue = func(context.Context) (*InspectionResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InspectionResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InspectionResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InspectionResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetResultName sets the result_name field.
func (m *InspectionResultMutation) SetResultName(s string) {
	m.result_name = &s
}

// ResultName returns the result_name value in the mutation.
func (m *InspectionResultMutation) ResultName() (r string, exists bool) {
	v := m.result_name
	if v == nil {
		return
	}
	return *v, true
}

// OldResultName returns the old result_name value of the InspectionResult.
// If the InspectionResult object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionResultMutation) OldResultName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResultName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResultName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultName: %w", err)
	}
	return oldValue.ResultName, nil
}

// ResetResultName reset all changes of the "result_name" field.
func (m *InspectionResultMutation) ResetResultName() {
	m.result_name = nil
}

// AddCarinspectionIDs adds the carinspections edge to CarInspection by ids.
func (m *InspectionResultMutation) AddCarinspectionIDs(ids ...int) {
	if m.carinspections == nil {
		m.carinspections = make(map[int]struct{})
	}
	for i := range ids {
		m.carinspections[ids[i]] = struct{}{}
	}
}

// RemoveCarinspectionIDs removes the carinspections edge to CarInspection by ids.
func (m *InspectionResultMutation) RemoveCarinspectionIDs(ids ...int) {
	if m.removedcarinspections == nil {
		m.removedcarinspections = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcarinspections[ids[i]] = struct{}{}
	}
}

// RemovedCarinspections returns the removed ids of carinspections.
func (m *InspectionResultMutation) RemovedCarinspectionsIDs() (ids []int) {
	for id := range m.removedcarinspections {
		ids = append(ids, id)
	}
	return
}

// CarinspectionsIDs returns the carinspections ids in the mutation.
func (m *InspectionResultMutation) CarinspectionsIDs() (ids []int) {
	for id := range m.carinspections {
		ids = append(ids, id)
	}
	return
}

// ResetCarinspections reset all changes of the "carinspections" edge.
func (m *InspectionResultMutation) ResetCarinspections() {
	m.carinspections = nil
	m.removedcarinspections = nil
}

// AddStatusofIDs adds the statusof edge to Ambulance by ids.
func (m *InspectionResultMutation) AddStatusofIDs(ids ...int) {
	if m.statusof == nil {
		m.statusof = make(map[int]struct{})
	}
	for i := range ids {
		m.statusof[ids[i]] = struct{}{}
	}
}

// RemoveStatusofIDs removes the statusof edge to Ambulance by ids.
func (m *InspectionResultMutation) RemoveStatusofIDs(ids ...int) {
	if m.removedstatusof == nil {
		m.removedstatusof = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstatusof[ids[i]] = struct{}{}
	}
}

// RemovedStatusof returns the removed ids of statusof.
func (m *InspectionResultMutation) RemovedStatusofIDs() (ids []int) {
	for id := range m.removedstatusof {
		ids = append(ids, id)
	}
	return
}

// StatusofIDs returns the statusof ids in the mutation.
func (m *InspectionResultMutation) StatusofIDs() (ids []int) {
	for id := range m.statusof {
		ids = append(ids, id)
	}
	return
}

// ResetStatusof reset all changes of the "statusof" edge.
func (m *InspectionResultMutation) ResetStatusof() {
	m.statusof = nil
	m.removedstatusof = nil
}

// SetJobpositionID sets the jobposition edge to JobPosition by id.
func (m *InspectionResultMutation) SetJobpositionID(id int) {
	m.jobposition = &id
}

// ClearJobposition clears the jobposition edge to JobPosition.
func (m *InspectionResultMutation) ClearJobposition() {
	m.clearedjobposition = true
}

// JobpositionCleared returns if the edge jobposition was cleared.
func (m *InspectionResultMutation) JobpositionCleared() bool {
	return m.clearedjobposition
}

// JobpositionID returns the jobposition id in the mutation.
func (m *InspectionResultMutation) JobpositionID() (id int, exists bool) {
	if m.jobposition != nil {
		return *m.jobposition, true
	}
	return
}

// JobpositionIDs returns the jobposition ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// JobpositionID instead. It exists only for internal usage by the builders.
func (m *InspectionResultMutation) JobpositionIDs() (ids []int) {
	if id := m.jobposition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJobposition reset all changes of the "jobposition" edge.
func (m *InspectionResultMutation) ResetJobposition() {
	m.jobposition = nil
	m.clearedjobposition = false
}

// Op returns the operation name.
func (m *InspectionResultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InspectionResult).
func (m *InspectionResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InspectionResultMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.result_name != nil {
		fields = append(fields, inspectionresult.FieldResultName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InspectionResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inspectionresult.FieldResultName:
		return m.ResultName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *InspectionResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inspectionresult.FieldResultName:
		return m.OldResultName(ctx)
	}
	return nil, fmt.Errorf("unknown InspectionResult field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InspectionResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inspectionresult.FieldResultName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultName(v)
		return nil
	}
	return fmt.Errorf("unknown InspectionResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InspectionResultMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InspectionResultMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InspectionResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InspectionResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InspectionResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InspectionResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InspectionResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InspectionResult nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InspectionResultMutation) ResetField(name string) error {
	switch name {
	case inspectionresult.FieldResultName:
		m.ResetResultName()
		return nil
	}
	return fmt.Errorf("unknown InspectionResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InspectionResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.carinspections != nil {
		edges = append(edges, inspectionresult.EdgeCarinspections)
	}
	if m.statusof != nil {
		edges = append(edges, inspectionresult.EdgeStatusof)
	}
	if m.jobposition != nil {
		edges = append(edges, inspectionresult.EdgeJobposition)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InspectionResultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inspectionresult.EdgeCarinspections:
		ids := make([]ent.Value, 0, len(m.carinspections))
		for id := range m.carinspections {
			ids = append(ids, id)
		}
		return ids
	case inspectionresult.EdgeStatusof:
		ids := make([]ent.Value, 0, len(m.statusof))
		for id := range m.statusof {
			ids = append(ids, id)
		}
		return ids
	case inspectionresult.EdgeJobposition:
		if id := m.jobposition; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InspectionResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcarinspections != nil {
		edges = append(edges, inspectionresult.EdgeCarinspections)
	}
	if m.removedstatusof != nil {
		edges = append(edges, inspectionresult.EdgeStatusof)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InspectionResultMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case inspectionresult.EdgeCarinspections:
		ids := make([]ent.Value, 0, len(m.removedcarinspections))
		for id := range m.removedcarinspections {
			ids = append(ids, id)
		}
		return ids
	case inspectionresult.EdgeStatusof:
		ids := make([]ent.Value, 0, len(m.removedstatusof))
		for id := range m.removedstatusof {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InspectionResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedjobposition {
		edges = append(edges, inspectionresult.EdgeJobposition)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InspectionResultMutation) EdgeCleared(name string) bool {
	switch name {
	case inspectionresult.EdgeJobposition:
		return m.clearedjobposition
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InspectionResultMutation) ClearEdge(name string) error {
	switch name {
	case inspectionresult.EdgeJobposition:
		m.ClearJobposition()
		return nil
	}
	return fmt.Errorf("unknown InspectionResult unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InspectionResultMutation) ResetEdge(name string) error {
	switch name {
	case inspectionresult.EdgeCarinspections:
		m.ResetCarinspections()
		return nil
	case inspectionresult.EdgeStatusof:
		m.ResetStatusof()
		return nil
	case inspectionresult.EdgeJobposition:
		m.ResetJobposition()
		return nil
	}
	return fmt.Errorf("unknown InspectionResult edge %s", name)
}

// InsuranceMutation represents an operation that mutate the Insurances
// nodes in the graph.
type InsuranceMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	company            *string
	clearedFields      map[string]struct{}
	insuranceof        map[int]struct{}
	removedinsuranceof map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Insurance, error)
}

var _ ent.Mutation = (*InsuranceMutation)(nil)

// insuranceOption allows to manage the mutation configuration using functional options.
type insuranceOption func(*InsuranceMutation)

// newInsuranceMutation creates new mutation for $n.Name.
func newInsuranceMutation(c config, op Op, opts ...insuranceOption) *InsuranceMutation {
	m := &InsuranceMutation{
		config:        c,
		op:            op,
		typ:           TypeInsurance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInsuranceID sets the id field of the mutation.
func withInsuranceID(id int) insuranceOption {
	return func(m *InsuranceMutation) {
		var (
			err   error
			once  sync.Once
			value *Insurance
		)
		m.oldValue = func(ctx context.Context) (*Insurance, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Insurance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInsurance sets the old Insurance of the mutation.
func withInsurance(node *Insurance) insuranceOption {
	return func(m *InsuranceMutation) {
		m.oldValue = func(context.Context) (*Insurance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InsuranceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InsuranceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InsuranceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCompany sets the company field.
func (m *InsuranceMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the company value in the mutation.
func (m *InsuranceMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old company value of the Insurance.
// If the Insurance object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InsuranceMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCompany is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ResetCompany reset all changes of the "company" field.
func (m *InsuranceMutation) ResetCompany() {
	m.company = nil
}

// AddInsuranceofIDs adds the insuranceof edge to Ambulance by ids.
func (m *InsuranceMutation) AddInsuranceofIDs(ids ...int) {
	if m.insuranceof == nil {
		m.insuranceof = make(map[int]struct{})
	}
	for i := range ids {
		m.insuranceof[ids[i]] = struct{}{}
	}
}

// RemoveInsuranceofIDs removes the insuranceof edge to Ambulance by ids.
func (m *InsuranceMutation) RemoveInsuranceofIDs(ids ...int) {
	if m.removedinsuranceof == nil {
		m.removedinsuranceof = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinsuranceof[ids[i]] = struct{}{}
	}
}

// RemovedInsuranceof returns the removed ids of insuranceof.
func (m *InsuranceMutation) RemovedInsuranceofIDs() (ids []int) {
	for id := range m.removedinsuranceof {
		ids = append(ids, id)
	}
	return
}

// InsuranceofIDs returns the insuranceof ids in the mutation.
func (m *InsuranceMutation) InsuranceofIDs() (ids []int) {
	for id := range m.insuranceof {
		ids = append(ids, id)
	}
	return
}

// ResetInsuranceof reset all changes of the "insuranceof" edge.
func (m *InsuranceMutation) ResetInsuranceof() {
	m.insuranceof = nil
	m.removedinsuranceof = nil
}

// Op returns the operation name.
func (m *InsuranceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Insurance).
func (m *InsuranceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InsuranceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.company != nil {
		fields = append(fields, insurance.FieldCompany)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InsuranceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case insurance.FieldCompany:
		return m.Company()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *InsuranceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case insurance.FieldCompany:
		return m.OldCompany(ctx)
	}
	return nil, fmt.Errorf("unknown Insurance field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InsuranceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case insurance.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	}
	return fmt.Errorf("unknown Insurance field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InsuranceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InsuranceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InsuranceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Insurance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InsuranceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InsuranceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InsuranceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Insurance nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InsuranceMutation) ResetField(name string) error {
	switch name {
	case insurance.FieldCompany:
		m.ResetCompany()
		return nil
	}
	return fmt.Errorf("unknown Insurance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InsuranceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.insuranceof != nil {
		edges = append(edges, insurance.EdgeInsuranceof)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InsuranceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case insurance.EdgeInsuranceof:
		ids := make([]ent.Value, 0, len(m.insuranceof))
		for id := range m.insuranceof {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InsuranceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedinsuranceof != nil {
		edges = append(edges, insurance.EdgeInsuranceof)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InsuranceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case insurance.EdgeInsuranceof:
		ids := make([]ent.Value, 0, len(m.removedinsuranceof))
		for id := range m.removedinsuranceof {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InsuranceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InsuranceMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InsuranceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Insurance unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InsuranceMutation) ResetEdge(name string) error {
	switch name {
	case insurance.EdgeInsuranceof:
		m.ResetInsuranceof()
		return nil
	}
	return fmt.Errorf("unknown Insurance edge %s", name)
}

// JobPositionMutation represents an operation that mutate the JobPositions
// nodes in the graph.
type JobPositionMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	position_name            *string
	clearedFields            map[string]struct{}
	users                    map[int]struct{}
	removedusers             map[int]struct{}
	inspectionresults        map[int]struct{}
	removedinspectionresults map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*JobPosition, error)
}

var _ ent.Mutation = (*JobPositionMutation)(nil)

// jobpositionOption allows to manage the mutation configuration using functional options.
type jobpositionOption func(*JobPositionMutation)

// newJobPositionMutation creates new mutation for $n.Name.
func newJobPositionMutation(c config, op Op, opts ...jobpositionOption) *JobPositionMutation {
	m := &JobPositionMutation{
		config:        c,
		op:            op,
		typ:           TypeJobPosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobPositionID sets the id field of the mutation.
func withJobPositionID(id int) jobpositionOption {
	return func(m *JobPositionMutation) {
		var (
			err   error
			once  sync.Once
			value *JobPosition
		)
		m.oldValue = func(ctx context.Context) (*JobPosition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobPosition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobPosition sets the old JobPosition of the mutation.
func withJobPosition(node *JobPosition) jobpositionOption {
	return func(m *JobPositionMutation) {
		m.oldValue = func(context.Context) (*JobPosition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobPositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobPositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *JobPositionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPositionName sets the position_name field.
func (m *JobPositionMutation) SetPositionName(s string) {
	m.position_name = &s
}

// PositionName returns the position_name value in the mutation.
func (m *JobPositionMutation) PositionName() (r string, exists bool) {
	v := m.position_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionName returns the old position_name value of the JobPosition.
// If the JobPosition object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *JobPositionMutation) OldPositionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPositionName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPositionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionName: %w", err)
	}
	return oldValue.PositionName, nil
}

// ResetPositionName reset all changes of the "position_name" field.
func (m *JobPositionMutation) ResetPositionName() {
	m.position_name = nil
}

// AddUserIDs adds the users edge to User by ids.
func (m *JobPositionMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// RemoveUserIDs removes the users edge to User by ids.
func (m *JobPositionMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed ids of users.
func (m *JobPositionMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the users ids in the mutation.
func (m *JobPositionMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers reset all changes of the "users" edge.
func (m *JobPositionMutation) ResetUsers() {
	m.users = nil
	m.removedusers = nil
}

// AddInspectionresultIDs adds the inspectionresults edge to InspectionResult by ids.
func (m *JobPositionMutation) AddInspectionresultIDs(ids ...int) {
	if m.inspectionresults == nil {
		m.inspectionresults = make(map[int]struct{})
	}
	for i := range ids {
		m.inspectionresults[ids[i]] = struct{}{}
	}
}

// RemoveInspectionresultIDs removes the inspectionresults edge to InspectionResult by ids.
func (m *JobPositionMutation) RemoveInspectionresultIDs(ids ...int) {
	if m.removedinspectionresults == nil {
		m.removedinspectionresults = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinspectionresults[ids[i]] = struct{}{}
	}
}

// RemovedInspectionresults returns the removed ids of inspectionresults.
func (m *JobPositionMutation) RemovedInspectionresultsIDs() (ids []int) {
	for id := range m.removedinspectionresults {
		ids = append(ids, id)
	}
	return
}

// InspectionresultsIDs returns the inspectionresults ids in the mutation.
func (m *JobPositionMutation) InspectionresultsIDs() (ids []int) {
	for id := range m.inspectionresults {
		ids = append(ids, id)
	}
	return
}

// ResetInspectionresults reset all changes of the "inspectionresults" edge.
func (m *JobPositionMutation) ResetInspectionresults() {
	m.inspectionresults = nil
	m.removedinspectionresults = nil
}

// Op returns the operation name.
func (m *JobPositionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (JobPosition).
func (m *JobPositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *JobPositionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.position_name != nil {
		fields = append(fields, jobposition.FieldPositionName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *JobPositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobposition.FieldPositionName:
		return m.PositionName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *JobPositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobposition.FieldPositionName:
		return m.OldPositionName(ctx)
	}
	return nil, fmt.Errorf("unknown JobPosition field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *JobPositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobposition.FieldPositionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionName(v)
		return nil
	}
	return fmt.Errorf("unknown JobPosition field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *JobPositionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *JobPositionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *JobPositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobPosition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *JobPositionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *JobPositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobPositionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown JobPosition nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *JobPositionMutation) ResetField(name string) error {
	switch name {
	case jobposition.FieldPositionName:
		m.ResetPositionName()
		return nil
	}
	return fmt.Errorf("unknown JobPosition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *JobPositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, jobposition.EdgeUsers)
	}
	if m.inspectionresults != nil {
		edges = append(edges, jobposition.EdgeInspectionresults)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *JobPositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobposition.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeInspectionresults:
		ids := make([]ent.Value, 0, len(m.inspectionresults))
		for id := range m.inspectionresults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *JobPositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, jobposition.EdgeUsers)
	}
	if m.removedinspectionresults != nil {
		edges = append(edges, jobposition.EdgeInspectionresults)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *JobPositionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobposition.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeInspectionresults:
		ids := make([]ent.Value, 0, len(m.removedinspectionresults))
		for id := range m.removedinspectionresults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *JobPositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *JobPositionMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *JobPositionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown JobPosition unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *JobPositionMutation) ResetEdge(name string) error {
	switch name {
	case jobposition.EdgeUsers:
		m.ResetUsers()
		return nil
	case jobposition.EdgeInspectionresults:
		m.ResetInspectionresults()
		return nil
	}
	return fmt.Errorf("unknown JobPosition edge %s", name)
}

// PurposeMutation represents an operation that mutate the Purposes
// nodes in the graph.
type PurposeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	objective            *string
	clearedFields        map[string]struct{}
	carcheckinout        map[int]struct{}
	removedcarcheckinout map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Purpose, error)
}

var _ ent.Mutation = (*PurposeMutation)(nil)

// purposeOption allows to manage the mutation configuration using functional options.
type purposeOption func(*PurposeMutation)

// newPurposeMutation creates new mutation for $n.Name.
func newPurposeMutation(c config, op Op, opts ...purposeOption) *PurposeMutation {
	m := &PurposeMutation{
		config:        c,
		op:            op,
		typ:           TypePurpose,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPurposeID sets the id field of the mutation.
func withPurposeID(id int) purposeOption {
	return func(m *PurposeMutation) {
		var (
			err   error
			once  sync.Once
			value *Purpose
		)
		m.oldValue = func(ctx context.Context) (*Purpose, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Purpose.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPurpose sets the old Purpose of the mutation.
func withPurpose(node *Purpose) purposeOption {
	return func(m *PurposeMutation) {
		m.oldValue = func(context.Context) (*Purpose, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PurposeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PurposeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PurposeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetObjective sets the objective field.
func (m *PurposeMutation) SetObjective(s string) {
	m.objective = &s
}

// Objective returns the objective value in the mutation.
func (m *PurposeMutation) Objective() (r string, exists bool) {
	v := m.objective
	if v == nil {
		return
	}
	return *v, true
}

// OldObjective returns the old objective value of the Purpose.
// If the Purpose object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PurposeMutation) OldObjective(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldObjective is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldObjective requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjective: %w", err)
	}
	return oldValue.Objective, nil
}

// ResetObjective reset all changes of the "objective" field.
func (m *PurposeMutation) ResetObjective() {
	m.objective = nil
}

// AddCarcheckinoutIDs adds the carcheckinout edge to CarCheckInOut by ids.
func (m *PurposeMutation) AddCarcheckinoutIDs(ids ...int) {
	if m.carcheckinout == nil {
		m.carcheckinout = make(map[int]struct{})
	}
	for i := range ids {
		m.carcheckinout[ids[i]] = struct{}{}
	}
}

// RemoveCarcheckinoutIDs removes the carcheckinout edge to CarCheckInOut by ids.
func (m *PurposeMutation) RemoveCarcheckinoutIDs(ids ...int) {
	if m.removedcarcheckinout == nil {
		m.removedcarcheckinout = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcarcheckinout[ids[i]] = struct{}{}
	}
}

// RemovedCarcheckinout returns the removed ids of carcheckinout.
func (m *PurposeMutation) RemovedCarcheckinoutIDs() (ids []int) {
	for id := range m.removedcarcheckinout {
		ids = append(ids, id)
	}
	return
}

// CarcheckinoutIDs returns the carcheckinout ids in the mutation.
func (m *PurposeMutation) CarcheckinoutIDs() (ids []int) {
	for id := range m.carcheckinout {
		ids = append(ids, id)
	}
	return
}

// ResetCarcheckinout reset all changes of the "carcheckinout" edge.
func (m *PurposeMutation) ResetCarcheckinout() {
	m.carcheckinout = nil
	m.removedcarcheckinout = nil
}

// Op returns the operation name.
func (m *PurposeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Purpose).
func (m *PurposeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PurposeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.objective != nil {
		fields = append(fields, purpose.FieldObjective)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PurposeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case purpose.FieldObjective:
		return m.Objective()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PurposeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case purpose.FieldObjective:
		return m.OldObjective(ctx)
	}
	return nil, fmt.Errorf("unknown Purpose field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PurposeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case purpose.FieldObjective:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjective(v)
		return nil
	}
	return fmt.Errorf("unknown Purpose field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PurposeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PurposeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PurposeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Purpose numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PurposeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PurposeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PurposeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Purpose nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PurposeMutation) ResetField(name string) error {
	switch name {
	case purpose.FieldObjective:
		m.ResetObjective()
		return nil
	}
	return fmt.Errorf("unknown Purpose field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PurposeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.carcheckinout != nil {
		edges = append(edges, purpose.EdgeCarcheckinout)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PurposeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case purpose.EdgeCarcheckinout:
		ids := make([]ent.Value, 0, len(m.carcheckinout))
		for id := range m.carcheckinout {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PurposeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcarcheckinout != nil {
		edges = append(edges, purpose.EdgeCarcheckinout)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PurposeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case purpose.EdgeCarcheckinout:
		ids := make([]ent.Value, 0, len(m.removedcarcheckinout))
		for id := range m.removedcarcheckinout {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PurposeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PurposeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PurposeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Purpose unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PurposeMutation) ResetEdge(name string) error {
	switch name {
	case purpose.EdgeCarcheckinout:
		m.ResetCarcheckinout()
		return nil
	}
	return fmt.Errorf("unknown Purpose edge %s", name)
}

// ReceiveMutation represents an operation that mutate the Receives
// nodes in the graph.
type ReceiveMutation struct {
	config
	op               Op
	typ              string
	id               *int
	sendname         *string
	clearedFields    map[string]struct{}
	receiveid        map[int]struct{}
	removedreceiveid map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Receive, error)
}

var _ ent.Mutation = (*ReceiveMutation)(nil)

// receiveOption allows to manage the mutation configuration using functional options.
type receiveOption func(*ReceiveMutation)

// newReceiveMutation creates new mutation for $n.Name.
func newReceiveMutation(c config, op Op, opts ...receiveOption) *ReceiveMutation {
	m := &ReceiveMutation{
		config:        c,
		op:            op,
		typ:           TypeReceive,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReceiveID sets the id field of the mutation.
func withReceiveID(id int) receiveOption {
	return func(m *ReceiveMutation) {
		var (
			err   error
			once  sync.Once
			value *Receive
		)
		m.oldValue = func(ctx context.Context) (*Receive, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Receive.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReceive sets the old Receive of the mutation.
func withReceive(node *Receive) receiveOption {
	return func(m *ReceiveMutation) {
		m.oldValue = func(context.Context) (*Receive, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReceiveMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReceiveMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ReceiveMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSendname sets the sendname field.
func (m *ReceiveMutation) SetSendname(s string) {
	m.sendname = &s
}

// Sendname returns the sendname value in the mutation.
func (m *ReceiveMutation) Sendname() (r string, exists bool) {
	v := m.sendname
	if v == nil {
		return
	}
	return *v, true
}

// OldSendname returns the old sendname value of the Receive.
// If the Receive object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReceiveMutation) OldSendname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSendname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSendname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendname: %w", err)
	}
	return oldValue.Sendname, nil
}

// ResetSendname reset all changes of the "sendname" field.
func (m *ReceiveMutation) ResetSendname() {
	m.sendname = nil
}

// AddReceiveidIDs adds the receiveid edge to Transport by ids.
func (m *ReceiveMutation) AddReceiveidIDs(ids ...int) {
	if m.receiveid == nil {
		m.receiveid = make(map[int]struct{})
	}
	for i := range ids {
		m.receiveid[ids[i]] = struct{}{}
	}
}

// RemoveReceiveidIDs removes the receiveid edge to Transport by ids.
func (m *ReceiveMutation) RemoveReceiveidIDs(ids ...int) {
	if m.removedreceiveid == nil {
		m.removedreceiveid = make(map[int]struct{})
	}
	for i := range ids {
		m.removedreceiveid[ids[i]] = struct{}{}
	}
}

// RemovedReceiveid returns the removed ids of receiveid.
func (m *ReceiveMutation) RemovedReceiveidIDs() (ids []int) {
	for id := range m.removedreceiveid {
		ids = append(ids, id)
	}
	return
}

// ReceiveidIDs returns the receiveid ids in the mutation.
func (m *ReceiveMutation) ReceiveidIDs() (ids []int) {
	for id := range m.receiveid {
		ids = append(ids, id)
	}
	return
}

// ResetReceiveid reset all changes of the "receiveid" edge.
func (m *ReceiveMutation) ResetReceiveid() {
	m.receiveid = nil
	m.removedreceiveid = nil
}

// Op returns the operation name.
func (m *ReceiveMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Receive).
func (m *ReceiveMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ReceiveMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.sendname != nil {
		fields = append(fields, receive.FieldSendname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ReceiveMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case receive.FieldSendname:
		return m.Sendname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ReceiveMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case receive.FieldSendname:
		return m.OldSendname(ctx)
	}
	return nil, fmt.Errorf("unknown Receive field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReceiveMutation) SetField(name string, value ent.Value) error {
	switch name {
	case receive.FieldSendname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendname(v)
		return nil
	}
	return fmt.Errorf("unknown Receive field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ReceiveMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ReceiveMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReceiveMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Receive numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ReceiveMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ReceiveMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReceiveMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Receive nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ReceiveMutation) ResetField(name string) error {
	switch name {
	case receive.FieldSendname:
		m.ResetSendname()
		return nil
	}
	return fmt.Errorf("unknown Receive field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ReceiveMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.receiveid != nil {
		edges = append(edges, receive.EdgeReceiveid)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ReceiveMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case receive.EdgeReceiveid:
		ids := make([]ent.Value, 0, len(m.receiveid))
		for id := range m.receiveid {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ReceiveMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedreceiveid != nil {
		edges = append(edges, receive.EdgeReceiveid)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ReceiveMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case receive.EdgeReceiveid:
		ids := make([]ent.Value, 0, len(m.removedreceiveid))
		for id := range m.removedreceiveid {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ReceiveMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ReceiveMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ReceiveMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Receive unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ReceiveMutation) ResetEdge(name string) error {
	switch name {
	case receive.EdgeReceiveid:
		m.ResetReceiveid()
		return nil
	}
	return fmt.Errorf("unknown Receive edge %s", name)
}

// RepairingMutation represents an operation that mutate the Repairings
// nodes in the graph.
type RepairingMutation struct {
	config
	op             Op
	typ            string
	id             *int
	repairpart     *string
	clearedFields  map[string]struct{}
	repairs        map[int]struct{}
	removedrepairs map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Repairing, error)
}

var _ ent.Mutation = (*RepairingMutation)(nil)

// repairingOption allows to manage the mutation configuration using functional options.
type repairingOption func(*RepairingMutation)

// newRepairingMutation creates new mutation for $n.Name.
func newRepairingMutation(c config, op Op, opts ...repairingOption) *RepairingMutation {
	m := &RepairingMutation{
		config:        c,
		op:            op,
		typ:           TypeRepairing,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepairingID sets the id field of the mutation.
func withRepairingID(id int) repairingOption {
	return func(m *RepairingMutation) {
		var (
			err   error
			once  sync.Once
			value *Repairing
		)
		m.oldValue = func(ctx context.Context) (*Repairing, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repairing.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepairing sets the old Repairing of the mutation.
func withRepairing(node *Repairing) repairingOption {
	return func(m *RepairingMutation) {
		m.oldValue = func(context.Context) (*Repairing, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepairingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepairingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RepairingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRepairpart sets the repairpart field.
func (m *RepairingMutation) SetRepairpart(s string) {
	m.repairpart = &s
}

// Repairpart returns the repairpart value in the mutation.
func (m *RepairingMutation) Repairpart() (r string, exists bool) {
	v := m.repairpart
	if v == nil {
		return
	}
	return *v, true
}

// OldRepairpart returns the old repairpart value of the Repairing.
// If the Repairing object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairingMutation) OldRepairpart(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRepairpart is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRepairpart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepairpart: %w", err)
	}
	return oldValue.Repairpart, nil
}

// ResetRepairpart reset all changes of the "repairpart" field.
func (m *RepairingMutation) ResetRepairpart() {
	m.repairpart = nil
}

// AddRepairIDs adds the repairs edge to CarRepairrecord by ids.
func (m *RepairingMutation) AddRepairIDs(ids ...int) {
	if m.repairs == nil {
		m.repairs = make(map[int]struct{})
	}
	for i := range ids {
		m.repairs[ids[i]] = struct{}{}
	}
}

// RemoveRepairIDs removes the repairs edge to CarRepairrecord by ids.
func (m *RepairingMutation) RemoveRepairIDs(ids ...int) {
	if m.removedrepairs == nil {
		m.removedrepairs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrepairs[ids[i]] = struct{}{}
	}
}

// RemovedRepairs returns the removed ids of repairs.
func (m *RepairingMutation) RemovedRepairsIDs() (ids []int) {
	for id := range m.removedrepairs {
		ids = append(ids, id)
	}
	return
}

// RepairsIDs returns the repairs ids in the mutation.
func (m *RepairingMutation) RepairsIDs() (ids []int) {
	for id := range m.repairs {
		ids = append(ids, id)
	}
	return
}

// ResetRepairs reset all changes of the "repairs" edge.
func (m *RepairingMutation) ResetRepairs() {
	m.repairs = nil
	m.removedrepairs = nil
}

// Op returns the operation name.
func (m *RepairingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Repairing).
func (m *RepairingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RepairingMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.repairpart != nil {
		fields = append(fields, repairing.FieldRepairpart)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RepairingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repairing.FieldRepairpart:
		return m.Repairpart()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RepairingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repairing.FieldRepairpart:
		return m.OldRepairpart(ctx)
	}
	return nil, fmt.Errorf("unknown Repairing field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RepairingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repairing.FieldRepairpart:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepairpart(v)
		return nil
	}
	return fmt.Errorf("unknown Repairing field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RepairingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RepairingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RepairingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Repairing numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RepairingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RepairingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepairingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Repairing nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RepairingMutation) ResetField(name string) error {
	switch name {
	case repairing.FieldRepairpart:
		m.ResetRepairpart()
		return nil
	}
	return fmt.Errorf("unknown Repairing field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RepairingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.repairs != nil {
		edges = append(edges, repairing.EdgeRepairs)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RepairingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repairing.EdgeRepairs:
		ids := make([]ent.Value, 0, len(m.repairs))
		for id := range m.repairs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RepairingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrepairs != nil {
		edges = append(edges, repairing.EdgeRepairs)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RepairingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case repairing.EdgeRepairs:
		ids := make([]ent.Value, 0, len(m.removedrepairs))
		for id := range m.removedrepairs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RepairingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RepairingMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RepairingMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Repairing unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RepairingMutation) ResetEdge(name string) error {
	switch name {
	case repairing.EdgeRepairs:
		m.ResetRepairs()
		return nil
	}
	return fmt.Errorf("unknown Repairing edge %s", name)
}

// SendMutation represents an operation that mutate the Sends
// nodes in the graph.
type SendMutation struct {
	config
	op            Op
	typ           string
	id            *int
	sendname      *string
	clearedFields map[string]struct{}
	sendid        map[int]struct{}
	removedsendid map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Send, error)
}

var _ ent.Mutation = (*SendMutation)(nil)

// sendOption allows to manage the mutation configuration using functional options.
type sendOption func(*SendMutation)

// newSendMutation creates new mutation for $n.Name.
func newSendMutation(c config, op Op, opts ...sendOption) *SendMutation {
	m := &SendMutation{
		config:        c,
		op:            op,
		typ:           TypeSend,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSendID sets the id field of the mutation.
func withSendID(id int) sendOption {
	return func(m *SendMutation) {
		var (
			err   error
			once  sync.Once
			value *Send
		)
		m.oldValue = func(ctx context.Context) (*Send, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Send.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSend sets the old Send of the mutation.
func withSend(node *Send) sendOption {
	return func(m *SendMutation) {
		m.oldValue = func(context.Context) (*Send, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SendMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SendMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SendMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSendname sets the sendname field.
func (m *SendMutation) SetSendname(s string) {
	m.sendname = &s
}

// Sendname returns the sendname value in the mutation.
func (m *SendMutation) Sendname() (r string, exists bool) {
	v := m.sendname
	if v == nil {
		return
	}
	return *v, true
}

// OldSendname returns the old sendname value of the Send.
// If the Send object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SendMutation) OldSendname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSendname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSendname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendname: %w", err)
	}
	return oldValue.Sendname, nil
}

// ResetSendname reset all changes of the "sendname" field.
func (m *SendMutation) ResetSendname() {
	m.sendname = nil
}

// AddSendidIDs adds the sendid edge to Transport by ids.
func (m *SendMutation) AddSendidIDs(ids ...int) {
	if m.sendid == nil {
		m.sendid = make(map[int]struct{})
	}
	for i := range ids {
		m.sendid[ids[i]] = struct{}{}
	}
}

// RemoveSendidIDs removes the sendid edge to Transport by ids.
func (m *SendMutation) RemoveSendidIDs(ids ...int) {
	if m.removedsendid == nil {
		m.removedsendid = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsendid[ids[i]] = struct{}{}
	}
}

// RemovedSendid returns the removed ids of sendid.
func (m *SendMutation) RemovedSendidIDs() (ids []int) {
	for id := range m.removedsendid {
		ids = append(ids, id)
	}
	return
}

// SendidIDs returns the sendid ids in the mutation.
func (m *SendMutation) SendidIDs() (ids []int) {
	for id := range m.sendid {
		ids = append(ids, id)
	}
	return
}

// ResetSendid reset all changes of the "sendid" edge.
func (m *SendMutation) ResetSendid() {
	m.sendid = nil
	m.removedsendid = nil
}

// Op returns the operation name.
func (m *SendMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Send).
func (m *SendMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SendMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.sendname != nil {
		fields = append(fields, send.FieldSendname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SendMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case send.FieldSendname:
		return m.Sendname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SendMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case send.FieldSendname:
		return m.OldSendname(ctx)
	}
	return nil, fmt.Errorf("unknown Send field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SendMutation) SetField(name string, value ent.Value) error {
	switch name {
	case send.FieldSendname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendname(v)
		return nil
	}
	return fmt.Errorf("unknown Send field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SendMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SendMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SendMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Send numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SendMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SendMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SendMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Send nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SendMutation) ResetField(name string) error {
	switch name {
	case send.FieldSendname:
		m.ResetSendname()
		return nil
	}
	return fmt.Errorf("unknown Send field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SendMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sendid != nil {
		edges = append(edges, send.EdgeSendid)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SendMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case send.EdgeSendid:
		ids := make([]ent.Value, 0, len(m.sendid))
		for id := range m.sendid {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SendMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsendid != nil {
		edges = append(edges, send.EdgeSendid)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SendMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case send.EdgeSendid:
		ids := make([]ent.Value, 0, len(m.removedsendid))
		for id := range m.removedsendid {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SendMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SendMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SendMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Send unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SendMutation) ResetEdge(name string) error {
	switch name {
	case send.EdgeSendid:
		m.ResetSendid()
		return nil
	}
	return fmt.Errorf("unknown Send edge %s", name)
}

// TransportMutation represents an operation that mutate the Transports
// nodes in the graph.
type TransportMutation struct {
	config
	op               Op
	typ              string
	id               *int
	clearedFields    map[string]struct{}
	sendid           *int
	clearedsendid    bool
	receiveid        *int
	clearedreceiveid bool
	user             *int
	cleareduser      bool
	ambulance        *int
	clearedambulance bool
	done             bool
	oldValue         func(context.Context) (*Transport, error)
}

var _ ent.Mutation = (*TransportMutation)(nil)

// transportOption allows to manage the mutation configuration using functional options.
type transportOption func(*TransportMutation)

// newTransportMutation creates new mutation for $n.Name.
func newTransportMutation(c config, op Op, opts ...transportOption) *TransportMutation {
	m := &TransportMutation{
		config:        c,
		op:            op,
		typ:           TypeTransport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransportID sets the id field of the mutation.
func withTransportID(id int) transportOption {
	return func(m *TransportMutation) {
		var (
			err   error
			once  sync.Once
			value *Transport
		)
		m.oldValue = func(ctx context.Context) (*Transport, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransport sets the old Transport of the mutation.
func withTransport(node *Transport) transportOption {
	return func(m *TransportMutation) {
		m.oldValue = func(context.Context) (*Transport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TransportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSendidID sets the sendid edge to Send by id.
func (m *TransportMutation) SetSendidID(id int) {
	m.sendid = &id
}

// ClearSendid clears the sendid edge to Send.
func (m *TransportMutation) ClearSendid() {
	m.clearedsendid = true
}

// SendidCleared returns if the edge sendid was cleared.
func (m *TransportMutation) SendidCleared() bool {
	return m.clearedsendid
}

// SendidID returns the sendid id in the mutation.
func (m *TransportMutation) SendidID() (id int, exists bool) {
	if m.sendid != nil {
		return *m.sendid, true
	}
	return
}

// SendidIDs returns the sendid ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SendidID instead. It exists only for internal usage by the builders.
func (m *TransportMutation) SendidIDs() (ids []int) {
	if id := m.sendid; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSendid reset all changes of the "sendid" edge.
func (m *TransportMutation) ResetSendid() {
	m.sendid = nil
	m.clearedsendid = false
}

// SetReceiveidID sets the receiveid edge to Receive by id.
func (m *TransportMutation) SetReceiveidID(id int) {
	m.receiveid = &id
}

// ClearReceiveid clears the receiveid edge to Receive.
func (m *TransportMutation) ClearReceiveid() {
	m.clearedreceiveid = true
}

// ReceiveidCleared returns if the edge receiveid was cleared.
func (m *TransportMutation) ReceiveidCleared() bool {
	return m.clearedreceiveid
}

// ReceiveidID returns the receiveid id in the mutation.
func (m *TransportMutation) ReceiveidID() (id int, exists bool) {
	if m.receiveid != nil {
		return *m.receiveid, true
	}
	return
}

// ReceiveidIDs returns the receiveid ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ReceiveidID instead. It exists only for internal usage by the builders.
func (m *TransportMutation) ReceiveidIDs() (ids []int) {
	if id := m.receiveid; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReceiveid reset all changes of the "receiveid" edge.
func (m *TransportMutation) ResetReceiveid() {
	m.receiveid = nil
	m.clearedreceiveid = false
}

// SetUserID sets the user edge to User by id.
func (m *TransportMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *TransportMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *TransportMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *TransportMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TransportMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *TransportMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetAmbulanceID sets the ambulance edge to Ambulance by id.
func (m *TransportMutation) SetAmbulanceID(id int) {
	m.ambulance = &id
}

// ClearAmbulance clears the ambulance edge to Ambulance.
func (m *TransportMutation) ClearAmbulance() {
	m.clearedambulance = true
}

// AmbulanceCleared returns if the edge ambulance was cleared.
func (m *TransportMutation) AmbulanceCleared() bool {
	return m.clearedambulance
}

// AmbulanceID returns the ambulance id in the mutation.
func (m *TransportMutation) AmbulanceID() (id int, exists bool) {
	if m.ambulance != nil {
		return *m.ambulance, true
	}
	return
}

// AmbulanceIDs returns the ambulance ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AmbulanceID instead. It exists only for internal usage by the builders.
func (m *TransportMutation) AmbulanceIDs() (ids []int) {
	if id := m.ambulance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAmbulance reset all changes of the "ambulance" edge.
func (m *TransportMutation) ResetAmbulance() {
	m.ambulance = nil
	m.clearedambulance = false
}

// Op returns the operation name.
func (m *TransportMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transport).
func (m *TransportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TransportMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TransportMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TransportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Transport field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TransportMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Transport field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TransportMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TransportMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TransportMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Transport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TransportMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TransportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransportMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Transport nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TransportMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Transport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TransportMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.sendid != nil {
		edges = append(edges, transport.EdgeSendid)
	}
	if m.receiveid != nil {
		edges = append(edges, transport.EdgeReceiveid)
	}
	if m.user != nil {
		edges = append(edges, transport.EdgeUser)
	}
	if m.ambulance != nil {
		edges = append(edges, transport.EdgeAmbulance)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TransportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transport.EdgeSendid:
		if id := m.sendid; id != nil {
			return []ent.Value{*id}
		}
	case transport.EdgeReceiveid:
		if id := m.receiveid; id != nil {
			return []ent.Value{*id}
		}
	case transport.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case transport.EdgeAmbulance:
		if id := m.ambulance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TransportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TransportMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TransportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsendid {
		edges = append(edges, transport.EdgeSendid)
	}
	if m.clearedreceiveid {
		edges = append(edges, transport.EdgeReceiveid)
	}
	if m.cleareduser {
		edges = append(edges, transport.EdgeUser)
	}
	if m.clearedambulance {
		edges = append(edges, transport.EdgeAmbulance)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TransportMutation) EdgeCleared(name string) bool {
	switch name {
	case transport.EdgeSendid:
		return m.clearedsendid
	case transport.EdgeReceiveid:
		return m.clearedreceiveid
	case transport.EdgeUser:
		return m.cleareduser
	case transport.EdgeAmbulance:
		return m.clearedambulance
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TransportMutation) ClearEdge(name string) error {
	switch name {
	case transport.EdgeSendid:
		m.ClearSendid()
		return nil
	case transport.EdgeReceiveid:
		m.ClearReceiveid()
		return nil
	case transport.EdgeUser:
		m.ClearUser()
		return nil
	case transport.EdgeAmbulance:
		m.ClearAmbulance()
		return nil
	}
	return fmt.Errorf("unknown Transport unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TransportMutation) ResetEdge(name string) error {
	switch name {
	case transport.EdgeSendid:
		m.ResetSendid()
		return nil
	case transport.EdgeReceiveid:
		m.ResetReceiveid()
		return nil
	case transport.EdgeUser:
		m.ResetUser()
		return nil
	case transport.EdgeAmbulance:
		m.ResetAmbulance()
		return nil
	}
	return fmt.Errorf("unknown Transport edge %s", name)
}

// UrgentMutation represents an operation that mutate the Urgents
// nodes in the graph.
type UrgentMutation struct {
	config
	op              Op
	typ             string
	id              *int
	urgent          *string
	clearedFields   map[string]struct{}
	urgentid        map[int]struct{}
	removedurgentid map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Urgent, error)
}

var _ ent.Mutation = (*UrgentMutation)(nil)

// urgentOption allows to manage the mutation configuration using functional options.
type urgentOption func(*UrgentMutation)

// newUrgentMutation creates new mutation for $n.Name.
func newUrgentMutation(c config, op Op, opts ...urgentOption) *UrgentMutation {
	m := &UrgentMutation{
		config:        c,
		op:            op,
		typ:           TypeUrgent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUrgentID sets the id field of the mutation.
func withUrgentID(id int) urgentOption {
	return func(m *UrgentMutation) {
		var (
			err   error
			once  sync.Once
			value *Urgent
		)
		m.oldValue = func(ctx context.Context) (*Urgent, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Urgent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUrgent sets the old Urgent of the mutation.
func withUrgent(node *Urgent) urgentOption {
	return func(m *UrgentMutation) {
		m.oldValue = func(context.Context) (*Urgent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UrgentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UrgentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UrgentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUrgent sets the urgent field.
func (m *UrgentMutation) SetUrgent(s string) {
	m.urgent = &s
}

// Urgent returns the urgent value in the mutation.
func (m *UrgentMutation) Urgent() (r string, exists bool) {
	v := m.urgent
	if v == nil {
		return
	}
	return *v, true
}

// OldUrgent returns the old urgent value of the Urgent.
// If the Urgent object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UrgentMutation) OldUrgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUrgent is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUrgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUrgent: %w", err)
	}
	return oldValue.Urgent, nil
}

// ResetUrgent reset all changes of the "urgent" field.
func (m *UrgentMutation) ResetUrgent() {
	m.urgent = nil
}

// AddUrgentidIDs adds the urgentid edge to Carservice by ids.
func (m *UrgentMutation) AddUrgentidIDs(ids ...int) {
	if m.urgentid == nil {
		m.urgentid = make(map[int]struct{})
	}
	for i := range ids {
		m.urgentid[ids[i]] = struct{}{}
	}
}

// RemoveUrgentidIDs removes the urgentid edge to Carservice by ids.
func (m *UrgentMutation) RemoveUrgentidIDs(ids ...int) {
	if m.removedurgentid == nil {
		m.removedurgentid = make(map[int]struct{})
	}
	for i := range ids {
		m.removedurgentid[ids[i]] = struct{}{}
	}
}

// RemovedUrgentid returns the removed ids of urgentid.
func (m *UrgentMutation) RemovedUrgentidIDs() (ids []int) {
	for id := range m.removedurgentid {
		ids = append(ids, id)
	}
	return
}

// UrgentidIDs returns the urgentid ids in the mutation.
func (m *UrgentMutation) UrgentidIDs() (ids []int) {
	for id := range m.urgentid {
		ids = append(ids, id)
	}
	return
}

// ResetUrgentid reset all changes of the "urgentid" edge.
func (m *UrgentMutation) ResetUrgentid() {
	m.urgentid = nil
	m.removedurgentid = nil
}

// Op returns the operation name.
func (m *UrgentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Urgent).
func (m *UrgentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UrgentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.urgent != nil {
		fields = append(fields, urgent.FieldUrgent)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UrgentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case urgent.FieldUrgent:
		return m.Urgent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UrgentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case urgent.FieldUrgent:
		return m.OldUrgent(ctx)
	}
	return nil, fmt.Errorf("unknown Urgent field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UrgentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case urgent.FieldUrgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUrgent(v)
		return nil
	}
	return fmt.Errorf("unknown Urgent field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UrgentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UrgentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UrgentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Urgent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UrgentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UrgentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UrgentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Urgent nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UrgentMutation) ResetField(name string) error {
	switch name {
	case urgent.FieldUrgent:
		m.ResetUrgent()
		return nil
	}
	return fmt.Errorf("unknown Urgent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UrgentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.urgentid != nil {
		edges = append(edges, urgent.EdgeUrgentid)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UrgentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case urgent.EdgeUrgentid:
		ids := make([]ent.Value, 0, len(m.urgentid))
		for id := range m.urgentid {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UrgentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedurgentid != nil {
		edges = append(edges, urgent.EdgeUrgentid)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UrgentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case urgent.EdgeUrgentid:
		ids := make([]ent.Value, 0, len(m.removedurgentid))
		for id := range m.removedurgentid {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UrgentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UrgentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UrgentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Urgent unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UrgentMutation) ResetEdge(name string) error {
	switch name {
	case urgent.EdgeUrgentid:
		m.ResetUrgentid()
		return nil
	}
	return fmt.Errorf("unknown Urgent edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	name                    *string
	email                   *string
	password                *string
	clearedFields           map[string]struct{}
	jobposition             *int
	clearedjobposition      bool
	userof                  map[int]struct{}
	removeduserof           map[int]struct{}
	userid                  map[int]struct{}
	removeduserid           map[int]struct{}
	carinspections          map[int]struct{}
	removedcarinspections   map[int]struct{}
	carrepairrecords        map[int]struct{}
	removedcarrepairrecords map[int]struct{}
	carcheckinout           map[int]struct{}
	removedcarcheckinout    map[int]struct{}
	user                    map[int]struct{}
	removeduser             map[int]struct{}
	done                    bool
	oldValue                func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetJobpositionID sets the jobposition edge to JobPosition by id.
func (m *UserMutation) SetJobpositionID(id int) {
	m.jobposition = &id
}

// ClearJobposition clears the jobposition edge to JobPosition.
func (m *UserMutation) ClearJobposition() {
	m.clearedjobposition = true
}

// JobpositionCleared returns if the edge jobposition was cleared.
func (m *UserMutation) JobpositionCleared() bool {
	return m.clearedjobposition
}

// JobpositionID returns the jobposition id in the mutation.
func (m *UserMutation) JobpositionID() (id int, exists bool) {
	if m.jobposition != nil {
		return *m.jobposition, true
	}
	return
}

// JobpositionIDs returns the jobposition ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// JobpositionID instead. It exists only for internal usage by the builders.
func (m *UserMutation) JobpositionIDs() (ids []int) {
	if id := m.jobposition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJobposition reset all changes of the "jobposition" edge.
func (m *UserMutation) ResetJobposition() {
	m.jobposition = nil
	m.clearedjobposition = false
}

// AddUserofIDs adds the userof edge to Ambulance by ids.
func (m *UserMutation) AddUserofIDs(ids ...int) {
	if m.userof == nil {
		m.userof = make(map[int]struct{})
	}
	for i := range ids {
		m.userof[ids[i]] = struct{}{}
	}
}

// RemoveUserofIDs removes the userof edge to Ambulance by ids.
func (m *UserMutation) RemoveUserofIDs(ids ...int) {
	if m.removeduserof == nil {
		m.removeduserof = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduserof[ids[i]] = struct{}{}
	}
}

// RemovedUserof returns the removed ids of userof.
func (m *UserMutation) RemovedUserofIDs() (ids []int) {
	for id := range m.removeduserof {
		ids = append(ids, id)
	}
	return
}

// UserofIDs returns the userof ids in the mutation.
func (m *UserMutation) UserofIDs() (ids []int) {
	for id := range m.userof {
		ids = append(ids, id)
	}
	return
}

// ResetUserof reset all changes of the "userof" edge.
func (m *UserMutation) ResetUserof() {
	m.userof = nil
	m.removeduserof = nil
}

// AddUseridIDs adds the userid edge to Carservice by ids.
func (m *UserMutation) AddUseridIDs(ids ...int) {
	if m.userid == nil {
		m.userid = make(map[int]struct{})
	}
	for i := range ids {
		m.userid[ids[i]] = struct{}{}
	}
}

// RemoveUseridIDs removes the userid edge to Carservice by ids.
func (m *UserMutation) RemoveUseridIDs(ids ...int) {
	if m.removeduserid == nil {
		m.removeduserid = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduserid[ids[i]] = struct{}{}
	}
}

// RemovedUserid returns the removed ids of userid.
func (m *UserMutation) RemovedUseridIDs() (ids []int) {
	for id := range m.removeduserid {
		ids = append(ids, id)
	}
	return
}

// UseridIDs returns the userid ids in the mutation.
func (m *UserMutation) UseridIDs() (ids []int) {
	for id := range m.userid {
		ids = append(ids, id)
	}
	return
}

// ResetUserid reset all changes of the "userid" edge.
func (m *UserMutation) ResetUserid() {
	m.userid = nil
	m.removeduserid = nil
}

// AddCarinspectionIDs adds the carinspections edge to CarInspection by ids.
func (m *UserMutation) AddCarinspectionIDs(ids ...int) {
	if m.carinspections == nil {
		m.carinspections = make(map[int]struct{})
	}
	for i := range ids {
		m.carinspections[ids[i]] = struct{}{}
	}
}

// RemoveCarinspectionIDs removes the carinspections edge to CarInspection by ids.
func (m *UserMutation) RemoveCarinspectionIDs(ids ...int) {
	if m.removedcarinspections == nil {
		m.removedcarinspections = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcarinspections[ids[i]] = struct{}{}
	}
}

// RemovedCarinspections returns the removed ids of carinspections.
func (m *UserMutation) RemovedCarinspectionsIDs() (ids []int) {
	for id := range m.removedcarinspections {
		ids = append(ids, id)
	}
	return
}

// CarinspectionsIDs returns the carinspections ids in the mutation.
func (m *UserMutation) CarinspectionsIDs() (ids []int) {
	for id := range m.carinspections {
		ids = append(ids, id)
	}
	return
}

// ResetCarinspections reset all changes of the "carinspections" edge.
func (m *UserMutation) ResetCarinspections() {
	m.carinspections = nil
	m.removedcarinspections = nil
}

// AddCarrepairrecordIDs adds the carrepairrecords edge to CarRepairrecord by ids.
func (m *UserMutation) AddCarrepairrecordIDs(ids ...int) {
	if m.carrepairrecords == nil {
		m.carrepairrecords = make(map[int]struct{})
	}
	for i := range ids {
		m.carrepairrecords[ids[i]] = struct{}{}
	}
}

// RemoveCarrepairrecordIDs removes the carrepairrecords edge to CarRepairrecord by ids.
func (m *UserMutation) RemoveCarrepairrecordIDs(ids ...int) {
	if m.removedcarrepairrecords == nil {
		m.removedcarrepairrecords = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcarrepairrecords[ids[i]] = struct{}{}
	}
}

// RemovedCarrepairrecords returns the removed ids of carrepairrecords.
func (m *UserMutation) RemovedCarrepairrecordsIDs() (ids []int) {
	for id := range m.removedcarrepairrecords {
		ids = append(ids, id)
	}
	return
}

// CarrepairrecordsIDs returns the carrepairrecords ids in the mutation.
func (m *UserMutation) CarrepairrecordsIDs() (ids []int) {
	for id := range m.carrepairrecords {
		ids = append(ids, id)
	}
	return
}

// ResetCarrepairrecords reset all changes of the "carrepairrecords" edge.
func (m *UserMutation) ResetCarrepairrecords() {
	m.carrepairrecords = nil
	m.removedcarrepairrecords = nil
}

// AddCarcheckinoutIDs adds the carcheckinout edge to CarCheckInOut by ids.
func (m *UserMutation) AddCarcheckinoutIDs(ids ...int) {
	if m.carcheckinout == nil {
		m.carcheckinout = make(map[int]struct{})
	}
	for i := range ids {
		m.carcheckinout[ids[i]] = struct{}{}
	}
}

// RemoveCarcheckinoutIDs removes the carcheckinout edge to CarCheckInOut by ids.
func (m *UserMutation) RemoveCarcheckinoutIDs(ids ...int) {
	if m.removedcarcheckinout == nil {
		m.removedcarcheckinout = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcarcheckinout[ids[i]] = struct{}{}
	}
}

// RemovedCarcheckinout returns the removed ids of carcheckinout.
func (m *UserMutation) RemovedCarcheckinoutIDs() (ids []int) {
	for id := range m.removedcarcheckinout {
		ids = append(ids, id)
	}
	return
}

// CarcheckinoutIDs returns the carcheckinout ids in the mutation.
func (m *UserMutation) CarcheckinoutIDs() (ids []int) {
	for id := range m.carcheckinout {
		ids = append(ids, id)
	}
	return
}

// ResetCarcheckinout reset all changes of the "carcheckinout" edge.
func (m *UserMutation) ResetCarcheckinout() {
	m.carcheckinout = nil
	m.removedcarcheckinout = nil
}

// AddUserIDs adds the user edge to Transport by ids.
func (m *UserMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// RemoveUserIDs removes the user edge to Transport by ids.
func (m *UserMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed ids of user.
func (m *UserMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the user ids in the mutation.
func (m *UserMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *UserMutation) ResetUser() {
	m.user = nil
	m.removeduser = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.jobposition != nil {
		edges = append(edges, user.EdgeJobposition)
	}
	if m.userof != nil {
		edges = append(edges, user.EdgeUserof)
	}
	if m.userid != nil {
		edges = append(edges, user.EdgeUserid)
	}
	if m.carinspections != nil {
		edges = append(edges, user.EdgeCarinspections)
	}
	if m.carrepairrecords != nil {
		edges = append(edges, user.EdgeCarrepairrecords)
	}
	if m.carcheckinout != nil {
		edges = append(edges, user.EdgeCarcheckinout)
	}
	if m.user != nil {
		edges = append(edges, user.EdgeUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeJobposition:
		if id := m.jobposition; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeUserof:
		ids := make([]ent.Value, 0, len(m.userof))
		for id := range m.userof {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserid:
		ids := make([]ent.Value, 0, len(m.userid))
		for id := range m.userid {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCarinspections:
		ids := make([]ent.Value, 0, len(m.carinspections))
		for id := range m.carinspections {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCarrepairrecords:
		ids := make([]ent.Value, 0, len(m.carrepairrecords))
		for id := range m.carrepairrecords {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCarcheckinout:
		ids := make([]ent.Value, 0, len(m.carcheckinout))
		for id := range m.carcheckinout {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removeduserof != nil {
		edges = append(edges, user.EdgeUserof)
	}
	if m.removeduserid != nil {
		edges = append(edges, user.EdgeUserid)
	}
	if m.removedcarinspections != nil {
		edges = append(edges, user.EdgeCarinspections)
	}
	if m.removedcarrepairrecords != nil {
		edges = append(edges, user.EdgeCarrepairrecords)
	}
	if m.removedcarcheckinout != nil {
		edges = append(edges, user.EdgeCarcheckinout)
	}
	if m.removeduser != nil {
		edges = append(edges, user.EdgeUser)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserof:
		ids := make([]ent.Value, 0, len(m.removeduserof))
		for id := range m.removeduserof {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserid:
		ids := make([]ent.Value, 0, len(m.removeduserid))
		for id := range m.removeduserid {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCarinspections:
		ids := make([]ent.Value, 0, len(m.removedcarinspections))
		for id := range m.removedcarinspections {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCarrepairrecords:
		ids := make([]ent.Value, 0, len(m.removedcarrepairrecords))
		for id := range m.removedcarrepairrecords {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCarcheckinout:
		ids := make([]ent.Value, 0, len(m.removedcarcheckinout))
		for id := range m.removedcarcheckinout {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedjobposition {
		edges = append(edges, user.EdgeJobposition)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeJobposition:
		return m.clearedjobposition
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeJobposition:
		m.ClearJobposition()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeJobposition:
		m.ResetJobposition()
		return nil
	case user.EdgeUserof:
		m.ResetUserof()
		return nil
	case user.EdgeUserid:
		m.ResetUserid()
		return nil
	case user.EdgeCarinspections:
		m.ResetCarinspections()
		return nil
	case user.EdgeCarrepairrecords:
		m.ResetCarrepairrecords()
		return nil
	case user.EdgeCarcheckinout:
		m.ResetCarcheckinout()
		return nil
	case user.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
